{"meta":{"title":"Morsol","subtitle":"","description":"","author":"morsol","url":"http://moersuo.github.io","root":"/moersuo.github.io/"},"pages":[],"posts":[{"title":"剑指offer58-1：翻转单词顺序","slug":"剑指offer58-1：翻转单词顺序","date":"2021-06-06T03:07:35.000Z","updated":"2021-06-06T06:22:23.553Z","comments":true,"path":"2021/06/06/剑指offer58-1：翻转单词顺序/","link":"","permalink":"http://moersuo.github.io/2021/06/06/%E5%89%91%E6%8C%87offer58-1%EF%BC%9A%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/","excerpt":"","text":"翻转单词顺序题目： 输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。 实例： 示例 1： 输入: “the sky is blue”输出: “blue is sky the”示例 2： 输入: “ hello world! “输出: “world! hello”解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。示例 3： 输入: “a good example”输出: “example good a”解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 双指针解法：思路： 使用trim()方法，去除字符串两边的空格 使用双指针i&amp;j，均指向最后一个字符位置。建立可编辑的StringBuilder类型字符串res。 从后向前遍历，直到遇见第一个空格，将其存入res中，并添加一个空字符充当遇到的空格。 再进行遍历，略过多余空格，直到遇见字符，并将其位置赋值给j，作为新的循环开始。 代码：123456789101112131415class Solution &#123; public String reverseWords(String s) &#123; s = s.trim(); int j = s.length() - 1, i = j; StringBuilder res = new StringBuilder(); while(i &gt;= 0 )&#123; while( i &gt;= 0 &amp;&amp; s.charAt(i) != ' ') i--; res.append(s.substring(i+1,j+1) + \" \"); while(i &gt;= 0 &amp;&amp; s.charAt(i) == ' ') i--; j = i; &#125; return res.toString().trim(); &#125;&#125; 复杂度分析：时间复杂度：O(N) 空间复杂度：O(N)","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"剑指offer","slug":"算法/剑指offer","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://moersuo.github.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"Leetcode题解92：反转链表||","slug":"Leetcode题解92：反转链表","date":"2021-05-30T02:32:51.000Z","updated":"2021-05-30T07:01:12.910Z","comments":true,"path":"2021/05/30/Leetcode题解92：反转链表/","link":"","permalink":"http://moersuo.github.io/2021/05/30/Leetcode%E9%A2%98%E8%A7%A392%EF%BC%9A%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","excerpt":"","text":"反转链表 II题目： 给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。 示例： 12&gt;输入：head &#x3D; [1,2,3,4,5], left &#x3D; 2, right &#x3D; 4&gt;输出：[1,4,3,2,5] 官方法一（繁琐）思路： 定义一个虚拟节点作为头结点，方便处理 定义一个被反转链表的前节点pre，和一个被反转链表的后节点curr。并切断这两个节点与被反转链表间的联系。 定义一个反转方法，反转该链表，并重新与pre和curr建立联系。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode reverseBetween(ListNode head, int left, int right) &#123; ListNode dummyNode = new ListNode(-1); dummyNode.next = head; ListNode pre = dummyNode; for(int i = 0; i &lt; left - 1; i++)&#123; pre = pre.next; &#125; ListNode rightNode = pre; for(int i = 0; i &lt; right - left +1; i++)&#123; rightNode = pre.next; &#125; ListNode leftNode = pre.next; ListNode curr = rightNode.next; pre.next = null; rightNode.next = null; reverseLinkedList(leftNode); pre.next = rightNode; leftNode.next = curr; return dummyNode.next; &#125; public void reverseLinkedList(ListNode head)&#123; ListNode pre = null; ListNode cur = head; while(cur != null)&#123; ListNode next = cur.next; cur.next = pre; pre = cur; cur = next; &#125; &#125;&#125; 复杂度分析： 时间复杂度：O(N)，其中 N 是链表总节点数。最坏情况下，需要遍历整个链表。 空间复杂度：O(1)。只使用到常数个变量。 官方法二：思路： 该进了方法一需要遍历两次的缺点，只需遍历一次，在遍历途中完成链表反转。 每次遍历时将遍历到的节点插入反转起始位置 使用三个指针变量，pre，cur，next。pre固定不动，永远指向反转区域首节点的前一个节点。cur指向反转区域首节点left，next永远指向cur的下一个节点。 操作步骤： 先将curr的下一个节点记录为next 执行操作 ①：把 curr 的下一个节点指向 next 的下一个节点； 执行操作 ②：把 next 的下一个节点指向 pre 的下一个节点； 执行操作 ③：把 pre 的下一个节点指向 next。 代码：1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode reverseBetween(ListNode head, int left, int right) &#123; ListNode dummyNode = new ListNode(-1); dummyNode.next = head; ListNode pre = dummyNode; for(int i = 0; i &lt; left - 1; i++)&#123; pre = pre.next; &#125; ListNode cur = pre.next; ListNode next; for(int i = 0; i &lt; right - left; i++)&#123; next = cur.next; cur.next = next.next; next.next = pre.next;; pre.next = next; &#125; return dummyNode.next; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode题解","slug":"算法/Leetcode题解","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://moersuo.github.io/tags/Leetcode%E9%A2%98%E8%A7%A3/"}]},{"title":"Leetcode题解62：不同路径","slug":"Leetcode题解62-不同路径","date":"2021-05-18T09:48:53.000Z","updated":"2021-05-19T00:22:06.217Z","comments":true,"path":"2021/05/18/Leetcode题解62-不同路径/","link":"","permalink":"http://moersuo.github.io/2021/05/18/Leetcode%E9%A2%98%E8%A7%A362-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/","excerpt":"","text":"不同路径题目： 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。 问总共有多少条不同的路径？ 示例： 123456789101112131.输入：m &#x3D; 3, n &#x3D; 7输出：282.输入：m &#x3D; 3, n &#x3D; 2输出：3解释：从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向下3.输入：m &#x3D; 7, n &#x3D; 3输出：28 动态规划法一：思路： 这是一道数学上的排列组合问题，除第一行和第一列均为1外，任一方格值均为其上方格路径数与左方格路径数量之和。因此可归纳为动态规划问题。 我们设置一个二维m*n的dp数组，并得出动态方程dp[i][j] = dp[i-1][j]+dp[i][j-1] 代码：12345678910111213class Solution &#123; public int uniquePaths(int m, int n) &#123; int[][] dp = new int[m][n]; for(int i =0; i &lt; m; i++) dp[i][0] = 1; for(int i =0; i &lt; n; i++) dp[0][i] = 1; for(int i = 1; i &lt; m; i++)&#123; for(int j =1; j &lt; n; j++)&#123; dp[i][j] = dp[i-1][j]+dp[i][j-1]; &#125; &#125; return dp[m-1][n-1]; &#125;&#125; 时间复杂度：O(m*n)空间复杂度：O(m*n)","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode题解","slug":"算法/Leetcode题解","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://moersuo.github.io/tags/Leetcode%E9%A2%98%E8%A7%A3/"}]},{"title":"Leetcode题解104：二叉树的最大深度","slug":"LeetCode题解104：二叉树的最大深度","date":"2021-05-14T23:32:46.000Z","updated":"2021-05-18T15:03:32.977Z","comments":true,"path":"2021/05/15/LeetCode题解104：二叉树的最大深度/","link":"","permalink":"http://moersuo.github.io/2021/05/15/LeetCode%E9%A2%98%E8%A7%A3104%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/","excerpt":"","text":"二叉树的最大深度题目： 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例 给定二叉树 [3,9,20,null,null,15,7]， 3 / \\ 9 20 / \\ 15 7 返回它的最大深度 3 。 递归解决：思路： 首先我们要找出递归的终止条件，因为是二叉树，所以当根节点为null时，也就不计算入最大深度，即可返回0 其次要找出等价关系 众所周知，二叉树分为左子树与右子树，我们所要取得最大深度便是在某一较长的子树上。因此，我们可以不断递归求出每一层中拥有较长子树的那一个节点，再将其作为根节点继续遍历。 每次遍历我们都进入了一层，因此每次都在递归等式上+1，直到null为止。 代码：1234567891011121314151617181920212223/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public int maxDepth(TreeNode root) &#123; if(root == null) return 0; int leftHeight = maxDepth(root.left); int rightHeight = maxDepth(root.right); return Math.max(leftHeight,rightHeight) +1; &#125;&#125; 时间复杂度：O(n)空间复杂度：O(height)","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode题解","slug":"算法/Leetcode题解","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://moersuo.github.io/tags/Leetcode%E9%A2%98%E8%A7%A3/"}]},{"title":"剑指offer07：重建二叉树","slug":"剑指offer07：重建二叉树","date":"2020-10-30T02:24:39.000Z","updated":"2020-10-30T04:24:28.900Z","comments":true,"path":"2020/10/30/剑指offer07：重建二叉树/","link":"","permalink":"http://moersuo.github.io/2020/10/30/%E5%89%91%E6%8C%87offer07%EF%BC%9A%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"题目： 输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 示例： 12345678910给出前序遍历 preorder &#x3D; [3,9,20,15,7]中序遍历 inorder &#x3D; [9,3,15,20,7]返回如下的二叉树： 3 &#x2F; \\ 9 20 &#x2F; \\ 15 7限制：0 &lt;&#x3D; 节点个数 &lt;&#x3D; 5000 官方法一：递归思路： 前序遍历性质：根节点–&gt;左子树–&gt;右子树 中序遍历性质：左子树–&gt;根节点–&gt;右子树 由此可推出： 前序遍历的首元素为树的根节点node的值 在中序遍历中搜索根节点node的索引，可将中序遍历划分为，左子树–&gt;根节点–&gt;右子树 根据中序遍历中的左右子树的节点的数量，可将前序遍历划分为，根节点–&gt;左子树–&gt;右子树 通过以上三步，可确定三个节点1.树的根节点 2. 左子树的根节点 3 .右子树根节点。对于树的左右子树仍可使用以上步骤划分左右子树 以上子树的递推性质是分治算法的体现，因此我们考虑使用递归对所有子树进行划分。 分治算法解析： 递推参数：根节点在前序遍历的索引root，子树在中序遍历的左边界left，子树在中序遍历的右边界right 终止条件：当left &gt;r ight，代表已经越过叶结点，此时返回null（相等时表示为自己） 递推过程： 建立根节点node：节点值为preorder[root] 划分左右子树：查找根节点在中序遍历inorder中的索引 i 构建左右子树：开启左右子树递归 左子树：根节点索引—root+i；中序遍历左边界—left；中序遍历右边界—i-1 右子树：根节点索引—i-left+root+1（左子树长度+根节点索引+1）；中序遍历左边界—i+1；中序遍历右边界—right 返回值：回溯返回node，作为上一层递归中根节点的左/右子节点 代码：12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; int[] preorder; //保留的先序遍历 Map&lt;Integer,Integer&gt; indexRoot = new HashMap&lt;Integer,Integer&gt;(); //标记中序遍历 public TreeNode buildTree(int[] preorder, int[] inorder) &#123; this.preorder = preorder; for(int i = 0; i &lt; preorder.length;i++)&#123; indexRoot.put(inorder[i],i); &#125; return recur(0,0,preorder.length - 1); &#125; TreeNode recur(int root,int left,int right)&#123; if(left &gt; right) return null; TreeNode node = new TreeNode(preorder[root]); int i = indexRoot.get(preorder[root]); node.left = recur(root + 1,left, i -1); node.right = recur(root + i - left + 1,i + 1,right); return node; &#125;&#125; 复杂度分析： 时间复杂度: 其中 N为树的节点数量。初始化 HashMap 需遍历 inorder ，占用 O(N) 。递归共建立 N 个节点，每层递归中的节点建立、搜索操作占用 O(1) ，因此使用 O(N) 时间。 空间复杂度： HashMap 使用 O(N)额外空间。最差情况下，树退化为链表，递归深度达到 N，占用 O(N)额外空间；最好情况下，树为满二叉树，递归深度为 logN ，占用 O(logN) 额外空间。","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"剑指offer","slug":"算法/剑指offer","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://moersuo.github.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"初识jQuery","slug":"初识jQuery","date":"2020-10-29T03:20:14.000Z","updated":"2020-10-29T03:24:41.309Z","comments":true,"path":"2020/10/29/初识jQuery/","link":"","permalink":"http://moersuo.github.io/2020/10/29/%E5%88%9D%E8%AF%86jQuery/","excerpt":"","text":"一.jQuery简介 jQuery顾名思义，就是JavaScript和查询（Query），它是辅助JavaScript开发的js类库 JQuery的核心思想是，write less, do more，实现了很多浏览器兼容问题 样例： 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"https://libs.baidu.com/jquery/1.11.3/jquery.min.js\"&gt;&lt;/script&gt; &lt;!--百度官方压缩后的cdn公共库--&gt; &lt;script type = \"text/javascript\"&gt; $(function()&#123; //表示页面加载完成后，相当于window.onload = function()&#123;&#125; var $btnObj = $(\"#bu\"); //表示按id查询标签对象 $btnObj.click(function()&#123;//绑定单击事件 alert(\"jQuery 的单击事件\"); &#125;) &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button id = \"bu\"&gt;say hello&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 为按钮添加响应函数 使用jQuery查询到标签对象 使用标签对象.click（function（）{}）; 二.jQuery的核心函数 $是jQuery的核心函数，$()就是调用$这个函数 传入参数为函数，表示页面加载完成后，相当于window.onload = function(){} 传入参数为HTML字符串时， 会帮我们创建这个HTML标签对象 传入参数为选择器字符串时 $(“#id属性值”) id选择器，根据id查询标签对象 $(“标签名”) 标签名选择器，根据指定的标签名查询标签对象 $(“.class属性值”) 类型选择器 传入参数为Dom对象时，会把这个DOM对象专为jQuery对象 三. jQuery对象和Dom对象区别3.1 什么是jQuery对象和Dom对象Dom对象： 通过getElementById()查询出来的标签对象是Dom对象 通过getElementByName()查询出来的标签对象是Dom对象 通过getElementByTagName()查询出来的标签对象是Dom对象 通过getElement()创建的对象是Dom对象 Dom对象alert出来的效果为：object HTML标签名Element jQuery对象： 通过jQuery提供的API创建的对象，是jQuery对象 通过jQuery包装的Dom对象，是jQuery对象 通过jQuery提供的API查询到的对象，是jQuery对象 3.2 jQuery对象的本质 jQuery是Dom对象的数组+jQuery提供的一系列功能函数 3.3 jQuery对象和Dom对象使用上的区别 jQuery对象与Dom对象互相不能使用彼此的属性和方法 3.4 Dom对象和jQuery对象互转 Dom对象转化为jQuery对象 先有Dom对象 $(Dom对象) 便可转化完成 jQuery对象转化为Dom对象 先有jQuery对象 jQuery对象[下标]取出相应的Dom对象 四. jQuery属性操作html() 它可以设置和获取起始标签和结束标签中的内容，等同dom属性innerHTML text() text()它可以设置和获取起始标签和结束标签中的文本，等同dom属性innerText val() 它可以设置和获取表单项的value属性值 attr() 可以设置和获取属性值,不推荐操作checked,readOnly,selected,disabled等 prop() 可以设置和获取属性值，只推荐操作attr不推荐的操作 五. DOM的增删改内部插入： appendTo() a.appendTo(b) 把a插入到b子元素末尾，成为最后一个元素 prepednTo() a.prependTo(b) 把a插入到b所有子元素前面，成为第一个子元素 外部插入： insertAfter() a.insertAfater(b) 得到ba insertBefore() a.insertAfater(b) 得到ab 替换： replaceWith() a.replaceWith(b) 用b替换掉a replaceAll() a.replaceAll(b) 用a替换掉所有b 删除: remove() a.remove(); 删除a标签 empty() a.empty(); 清空a标签内的内容 六. css样式操作addClass() 添加样式 removeClass() 删除样式 toggleClass() 有就删除，没有就添加样式 offset() 获取和设置元素的坐标 七. jQuery动画基本动画： show() 将隐藏的元素显示 hide() 将可见的元素隐藏 toggle() 可见就隐藏，不可见就显示 以上动画方法都可以添加参数 第一个参数是动画执行时长，以毫秒为单位 第二个参数是动画的回调函数（动画完成后自动调用的函数） 淡入淡出动画： fadeIn() 淡入（慢慢可见） fadeOut() 淡出（慢慢消失） fadeTo() 在指定时长内慢慢的将透明度修改到指定的值（0完全不可见，1完全可见，0.5半透明） fadeToggle() 淡入淡出切换 参数添加同上 八. jQuery事件操作$(function(){});和window.onload = function(){}区别 jQuery页面加载完成之后先执行，原生js页面加载完成后执行 jQuery的页面加载完成之后是浏览器的内核解析完页面的标签创建好DOM对象之后就会马上执行 原生js的页面加载完成之后，除了要等浏览器内核解析完标签创建好对象，还要等标签显示时候需要的内容加载完成 原生js的页面加载完成后，只会执行最后一次的赋值函数 jQuery的页面加载完成之后，会把全部注册的function函数，依次顺序全部执行 jQuery中其他的事件处理方法：click() 它可以绑定单机事件，以及触发单击事件（传function为绑定，不传为触发） mouseover() 鼠标移入事件 mouseout() 鼠标移出事件 bind() 可以给元素一次性绑定一个或多个事件 one() 使用上和bind一样，但是one方法绑定的事件，只会触发一次 unbind() 同bind相反，解除事件的绑定 live() 也是用来绑定事件，它可以用来绑定选择器匹配的所有元素的事件，哪怕这个元素是后面动态绑定的也有效 事件的冒泡： 事件的冒泡指，父子元素同时监听同一个事件。当触发子元素事件的同时，同一个事件也被传递到了父元素的事件里去响应 在事件函数体内，return false; 可以阻止事件的冒泡传递 JavaScript事件对象： 事件对象，是封装有触发的事件信息的一个js对象 在给元素绑定事件的时候，在事件的function(event)参数列表中添加一个参数，这个参数名，我们习惯称为event,这个event就是js传递参事件处理函数的事件对象 九. jQuery选择器 jQuery选择器允许对HTML元素组或单个元素进行操作 jQuery 选择器基于元素的 id、类、类型、属性、属性值等”查找”（或选择）HTML 元素。 它基于已经存在的css选择器，除此之外，它还有一些自定义的选择器。 jQuery 中所有选择器都以美元符号开头：$()。 元素选择器： jQuery 元素选择器基于元素名选取元素。 在页面中选取所有&lt;p&gt;元素 $(“p”) id选择器： jQuery #id 选择器通过 HTML 元素的 id 属性选取指定的元素。页面中元素的 id 应该是唯一的，所以您要在页面中选取唯一的元素需要通过 #id 选择器。 $(“#test”) .class选择器 jQuery 类选择器可以通过指定的 class 查找元素。 $(“.test”) $(“*”) 选取所有元素 $(“this”) 选取当前HTML元素","categories":[{"name":"后端学习","slug":"后端学习","permalink":"http://moersuo.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"},{"name":"JavaWeb","slug":"后端学习/JavaWeb","permalink":"http://moersuo.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/JavaWeb/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://moersuo.github.io/tags/jQuery/"}]},{"title":"HTML+CSS+JS基础","slug":"HTML-CSS-JS基础","date":"2020-10-23T09:53:18.000Z","updated":"2020-10-25T02:20:23.474Z","comments":true,"path":"2020/10/23/HTML-CSS-JS基础/","link":"","permalink":"http://moersuo.github.io/2020/10/23/HTML-CSS-JS%E5%9F%BA%E7%A1%80/","excerpt":"","text":"一.HTML和CSS基本框架12345678910&lt;!DOCTYPE html&gt; &lt;!--约束，声明--&gt;&lt;html lang=\"zh-CN\"&gt; &lt;!--html标签标示html的开始，lang=\"zh-CN\"表示中文，html标签中包含两部分，head和body--&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;!--表示当前页面使用UTF-8字符集--&gt; &lt;title&gt;Hello&lt;/title&gt; &lt;!--表示标题--&gt;&lt;/head&gt;&lt;!--头信息--&gt;&lt;body&gt; &lt;!--整个html页面显示的主体--&gt; hello world！&lt;/body&gt;&lt;/html&gt; &lt;!--整个html的结束--&gt; 二.HTML标签2.1 标签的格式​ &lt;标签名&gt;封装的数据&lt;/标签名&gt; 2.2 标签名大小写不敏感2.3 标签的属性 基本属性：可以修改简单的样式效果 事件属性：可以直接设置事件响应后的代码 2.4 单标签和双标签 单标签格式：&lt;标签名/&gt; br 换行 hr水平线 双标签格式：&lt;标签名&gt;封装的数据&lt;/标签名&gt; 2.5 标签的语法 标签不能交叉嵌套 标签必须正确关闭 属性值必须加引号 注释不能嵌套 2.6 常用标签font字体标签：修饰文本 face属性修改字体 color修改颜色 size修改大小 特殊字符： &lt; 的实体名称：&amp;lt 大于号&gt;的实体名称: &amp;gt 空格 &amp;nbsp 标题标签： h1 - h6 （h1最大） align：对齐属性 left （默认） center right 超链接：从一个网页指向另一个网页的链接关系 使用a标签表示 href属性设置连接的地址 target属性设置哪个目标进行跳转 _self 表示当前页面 _blank 表示打开新页面进行跳转 列表标签： 无序列表： type属性可以修改列表项前的符号 列表项 有序列表： img标签：在html页面上显示图片 src属性可以设置图片的路径 javaSE中相对路径和绝对路径 相对路径：从工程名起算 绝对路径：盘符:/目录/文件名 在web中路径分为相对路径和绝对路径 相对路径： . 表示当前文件所在目录 .. 表示当前文件所在上一级目录 文件名 表示当前文件所在目录的文件，相当于./文件名（./可以省略） 绝对路径：http://ip:port/工程名/资源路径 width属性设置图片宽度 height属性设置图片高度 border属性设置边框 alt属性设置当指定路径找不到时，显示alt文字作为替换 table标签：表格标签 table： border width height align：设置表格相对于页面的对齐方式 cellspacing：设置单元格间距 tr：行标签 th：表头标签 td：单元标签 align设置单元格文本的对齐方式 colspan属性设置跨列 rowspan设置跨行 iframe框架标签（内嵌窗口） 可以在一个html页面上，开辟一个小区域，去加载一个单独的页面。 iframe和a标签组合使用的步骤 在iframe标签中使用name属性定义一个名称 在a标签的target属性上设置iframe的属性值 表单标签：form基本内容： html页面中，用来收集用户信息的所有元素集合，然后把这些信息发送给服务器。 &lt;input type=”text” vale=”默认值”&gt;文本输入框 &lt;input type=”password” vale=”默认值”&gt;密码输入框 &lt;input type=”radio” name=”性别”&gt; 单选框（name属性进行分组，checed=”checked”默认选中） &lt;input type=”checkbox”&gt;复选框 select标签：下拉列表框 option标签：下拉列表框中的选项，select=”selected”设置默认选中 textarea标签：表示多行文本输入框 rows属性设置可以显示几行的高度 cols属性设置每行可显示几个字符宽度 起始标签和结束标签中的内容为默认值 &lt;input type=”reset”&gt; 重置按钮，回复为默认值。value属性修改按钮上的文本 &lt;input type=”submit”&gt; 提交按钮，value属性修改按钮上的文本 &lt;input type=”button”&gt; 按钮，alue属性修改按钮上的文本 &lt;input type=”file”&gt; 文件上传域 &lt;input type=”hidden”&gt; 隐藏域，发送某些不需要用户看见的信息，会被服务器接受 表单格式化： 使用table标签 12345678910111213141516&lt;form&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt; &lt;input type=\"text\" vale=\"默认值\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt; &lt;input type=\"password\" vale=\"默认值\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt; 提交细节: action属性设置提交的服务器地址 method属性设置提交的防止GET（默认值）或POST GET请求特点： 浏览器地址栏中的地址是：action属性【+？+请求参数】，请求参数的格式：name=value&amp;name=value 不安全 有数据长度的限制 post请求特点： 浏览器地址栏中的地址只有action属性 相对于GET安全 理论上没有数据长度限制 表单提交时，数据没有发送给服务器的三种情况： 表单项没有name属性值 单选，复选（下拉列表中的option标签）都需要添加value属性，用来发送给服务器 表单项不在提交的form标签中 2.7 其他标签div标签： 默认独占一行 span标签： 它的长度是封装数据的长度 p段落标签： 默认会在段落的上方或下方各空出一行（如果已有就不再空） 三.css3.1 概述： css是层叠样式表单，是用于（增强）控制网页样式并允许将样式信息与网页内容分离的一种标记性语言 3.2 css语法规则:选择器： 浏览器根据选择器绝对受css样式影响的HTML元素（标签） 属性（property）： 是打算更改的样式名，并且每个属性都有一个值，属性和值被冒号分开，并由花括号包围，这样就组成了一个完整的样式声明（declaration），eg：p{color:blue} 多个声明：如果要定义不止一个声明，则需要用分号将每个声明分开，虽然最后一条声明的最后可以不加分号（但尽量加）eg： 12345p&#123; color:red; font_size:30px;&#125;&lt;!--一般每行只写一个属性--&gt; 3.3 CSS结合HTML 在标签的style属性上设置“key:value value;”修改标签样式 在head标签中，使用style标签定义各种自己想要的css样式 12345&lt;style type=\"text/css\"&gt;xxx&#123; key:value value;&#125;&lt;/style&gt; 把css样式写成一个单独的css文件，再通过link标签引入即可复用 1234567&lt;head&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"theme.css\" /&gt;&lt;/head&gt;&lt;!--rel:规定当前文档与被链接文档之间的关系。 type:规定被链接文档的 MIME 类型。 href:规定被链接文档的位置。--&gt; 3.4 css选择器: 标签名选择器:可以决定哪些标签被动的使用这个样式 1234567891011121314151617&lt;!--标签名&#123; 属性：值；&#125;--&gt;&lt;style type=\"text/css\"&gt;div&#123; border: 1px solid yellow; color:blue; font-size；30px;&#125;span&#123; border: 1px solid yellow; color:blue; font-size；30px;&#125;&lt;/style&gt; id选择器：可以让我们通过id属性选择的去使用这个样式（需要在标签上定义id属性） 12345678910&lt;!--#id属性值&#123; 属性：值;&#125;--&gt;#id001&#123; border: 1px solid yellow; color:blue; font-size；30px;&#125; class类型选择器（类选择器）：可以通过class属性有效的选择性地去使用这个样式(需要在标签定义class属性) 12345&lt;!--.class属性值&#123; 属性：值&#125;--&gt; id与class区别：id唯一，class可以复用 组合选择器：组合选择器可以让多个选择器共用同一个css样式代码 1234&lt;!--选择器1，选择器2，选择器3&#123; 属性，值；&#125; 3.5 css常用样式 颜色：color:red 宽度：可以写像素值，或百分比值 高度：同宽度 背景颜色：blacground-color:#OF2CD 字体样式： color font-size 边框：border: div居中： margin-left:auto; margin-right:auto; 文本居中：text-align:center; 超链接去下划线：text-decoration:none; 表格细线： 1234567table&#123; border:1px solid black;&lt;!--设置边框--&gt; border-collapse:collapse;&lt;!--合并边框--&gt;&#125;td,th&#123; border:1px solid black;&lt;!--设置边框--&gt;&#125; 列表去除修饰： 123ul&#123; list-style:none;&#125; 四.JavaScript4.1 概述： JavaScript语言主要用来完成页面的数据验证，因此它运行在客户端，需要运行浏览器来解析执行JavaScript代码。JS是若类型，Java为强类型。（强类型指一个变量被定义类型后，如果不进行强制转换，则永远为该数据类型；弱类型定义的变量则可以随环境自行转换） 特点： 交互性—可以做信息的动态交互 安全性—不允许直接访问本地硬盘 跨平台性—只要可以解释JS的浏览器都可以执行，和平台无关 4.2 JavaScript和html的结合方式 在head标签或body标签中，使用script标签来书写JavaScript代码 12345&lt;script type = \"text/javascript\"&gt; //alert是javascript提供的一个警告函数 //可以接受任意类型的参数，这个参数就是警告框的提示信息 alert(\"Hello World\")&lt;/script&gt; 使用script标签引入单独的JavaScript代码文件 1234&lt;head&gt; &lt;script type = \"text/javascript\" src = \"1.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;!--src文件专门用来引入js文件路径，相对绝对均可--&gt; script标签定义js代码和引入js文件这两个功能，只能选其一使用 4.3 变量 变量类型; 数值类型：number 字符串类型：string 对象类型：object 布尔类型:boolean 函数类型：function 特殊值： undefined：未定义，所有js变量未赋初始值时默认值均为undefined null：空值 NAN(Not a Number)：非数字，非数值 变量定义格式 var 变量名; var 变量名 = 值； 关系（比较运算） 等于 == 简单的做字面值的比较 全等于 === 除了字面值的比较，还要比较变量的类型 逻辑运算 在js中，所有变量，都可以作为一个boolean变量去使用 0，null,undefined,””(空串) 均可视为false &amp;&amp;且运算 当表达式全为真时，返回最后一个表达式的值 当表达式中，有一个为假时，返回第一个为假的值 ||运算 当表达式全为假时，返回最后一个表达式的值 只有一个表达式为真，返回第一个为真的表达式的值 4.4 数组 数组定义方式： var 数组名={} //空数组 var 数组名={1,”abc”,true} //定义数组同时赋值元素 js中的数组，只要我们通过数组下标赋值，那么最大的下表值，就会自动的给数组扩容。 4.5 函数 可以通过function关键字定义函数 function 函数名(形参列表){函数体} 1234567891011121314151617&lt;script type = \"text/javascript\"&gt; function fun()&#123; alert(\"调用无参函数\"); &#125; fun(); function fun2(a,b)&#123; alert(\"调用有参函数\"+a+b); &#125; fun2(1,\"a\"); function sum(a,b)&#123; var result = a+b; return result; &#125; alert(sum(2,3))&lt;/script&gt;// 函数调用才会执行// 在js中，定义有返回值的函数，只需在函数体内直接使用return返回即可 var 函数名 = function(形参列表){函数体} 123456&lt;script type = \"text/javascript\"&gt; var fun3 = function(a,b)&#123; alert(\"有参函数\"); &#125; fun(1,2);&lt;/script&gt; 在js函数中可以重载，但会覆盖掉上一次的定义（不允许重载） 函数的arguments隐形参数（只在function函数内） 概念：在function中不需要定义，就可以直接用用来获取所有参数的变量。像java中的可变长参数,可以当作数组操作。 123456789101112&lt;script type = \"text/javascript\"&gt; function fun()&#123; alert(arguments[0]); alert(arguments[1]); alert(arguments[2]); for(var i = 0; i&lt;arguments.length;i++)&#123; alert(arguments[i]); &#125; alert(\"调用函数\"); &#125; fun(\"1\",1,true);&lt;/script&gt; 4.5 JS中的自定义对象Object形式的自定义对象： 对象的定义： var 变量名 = new Object{}; //对象实例（空对象） 变量名.属性名=值 //定义一个属性 变量名.函数名 = function(){} // 定义一个函数 对象的访问： 变量:属性/函数名(); {}形式的自定义对象： 对象的定义： var 变量名 = {}; //空对象 var 变量名 = {属性:值} //定义一个属性（若要定义多个内容，则使用逗号分开） var 变量名 = {函数名:function(){}} 对象的访问： 变量:属性/函数名(); 4.6 JS中的事件概念： 事件是电脑输入设备与页面进行交互的响应 常用的事件： onload 加载完成事件：页面加载完成后，常用来做页面js代码初始化操作 onclick 单机时间：常用于按钮的点击响应 onblur 失去焦点事件：常用于输入框失去焦点后验证其输入内容是否合法 onchange 内容发生改变事件：常用于下拉列表和输入框内容发生改变后操作 onsubmit 表单提交事件：常用于表单提交前，验证所有表单项是否合法 两种事件的注册（绑定）： 概念：告知浏览器，当事件响应结束后要执行哪些代码 静态注册事件：通过html标签的事件属性直接赋予事件响应后的代码 动态注册：先通过js代码得到标签的dom对象，然后再通过dom 对象.事件名 = function(){}，这种形式赋予事件响应后的代码。基本步骤： 获取标签对象 标签对象.事件名=function(){} onload事件： 12345678910111213&lt;!--静态注册onload事件--&gt;&lt;script type = \"text/javascript\"&gt; function onloadFun()&#123; alert(\"静态注册onload事件\"); &#125;&lt;/script&gt;&lt;body onload=\"onloadFun();\"&gt;&lt;!--动态注册onload事件--&gt;&lt;script type = \"text/javascript\"&gt; window.onload = function()&#123; alert(\"动态注册onload事件\"); &#125;&lt;/script&gt; onclick事件123456789101112131415161718192021222324252627&lt;!--静态注册onclick事件--&gt;&lt;script type = \"text/javascript\"&gt; function onclickFun()&#123; alert(\"静态注册onclick事件\"); &#125;&lt;/script&gt;&lt;body&gt; &lt;button onclick = \"onclickFun()\"&gt; 按钮 &lt;/button&gt;&lt;/body&gt;&lt;!--动态注册onclick事件--&gt;&lt;script type = \"text/javascript\"&gt; window.onload = function()&#123; // document是js中提供的一个对象（文档） // getElementById 通过id属性获取标签对象 var btnObj = document.getElementById(\"btn1\") btnObj.onclick = function()&#123; alert(\"动态注册onclick事件\"); &#125; &#125;&lt;/script&gt;&lt;body&gt; &lt;button id = btn1\"&gt; 按钮 &lt;/button&gt;&lt;/body&gt; onblur事件：1234567891011121314151617181920212223242526&lt;!--静态注册onblur事件--&gt;&lt;script type &#x3D; &quot;text&#x2F;javascript&quot;&gt; function onblurFun()&#123; &#x2F;&#x2F; comsole是控制台对象，由js提供，专门用来向浏览器的控制器打印输出，用于测试使用 &#x2F;&#x2F;log 是打印的方法 console.log(&quot;静态注册失去焦点事件&quot;)； &#125;&lt;&#x2F;script&gt;&lt;body&gt; 用户名:&lt;input type &#x3D; &quot;text&quot; onblur&#x3D;&quot;onblurFun();&quot;&gt;&lt;br&#x2F;&gt; 密码:&lt;input type &#x3D; &quot;text&quot;&quot;&gt;&lt;&#x2F;body&gt;&lt;!--动态注册onblur事件--&gt;&lt;script type &#x3D; &quot;text&#x2F;javascript&quot;&gt; window.onload &#x3D; function()&#123; var passworldObj &#x3D; document.getElementById(&quot;passworld&quot;); passworldObj.onblur &#x3D; function()&#123; console.log(&quot;动态注册失去焦点事件&quot;)； &#125; &#125; &lt;&#x2F;script&gt;&lt;body&gt; 用户名:&lt;input type &#x3D; &quot;text&quot; onblur&#x3D;&quot;onblurFun();&quot;&gt;&lt;br&#x2F;&gt; 密码:&lt;input id &#x3D; &quot;passworld&quot; type &#x3D; &quot;text&quot;&quot;&gt;&lt;&#x2F;body&gt; onchange事件:1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script&gt; function onchangeFun()&#123; alert(\"number was changed\"); &#125; window.onload = function()&#123; var selObj = document.getElementById(\"se1\"); selObj.onchange = function()&#123; alert(\"size was changed\"); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!--静态注册onchange事件--&gt; &lt;select onchange=\"onchangeFun();\"&gt; &lt;option&gt;--number--&lt;/option&gt; &lt;option&gt;--1--&lt;/option&gt; &lt;option&gt;--2--&lt;/option&gt; &lt;option&gt;--3--&lt;/option&gt; &lt;/select&gt; &lt;!--动态注册onchange事件--&gt; &lt;select id = \"se1\"&gt; &lt;option&gt;--size--&lt;/option&gt; &lt;option&gt;--s--&lt;/option&gt; &lt;option&gt;--m--&lt;/option&gt; &lt;option&gt;--l--&lt;/option&gt; &lt;/select&gt;&lt;/body&gt;&lt;/html&gt; onsubmit事件：123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script&gt; //静态注册表单提交事件 function onsubmitFun()&#123; // 要验证所有表单项是否合法，如果有一个不合法就阻止表单提交 alert(\"静态注册表单提交事件--发现不合法\"); return false; &#125; //动态注册 window.onload = function()&#123; var formObj = document.getElemenBytId(\"fo1\"); formObj.onsubmit = function()&#123; alert(\"静态注册表单提交事件--发现不合法\"); return false; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!--return false 可以阻止表单提交--&gt; &lt;form action = \"http://localhost:8080\" method=\"get\" onsubmit=\" return onsubmitFun();\"&gt; &lt;input type = \"submit\" value = \"静态注册\"/&gt; &lt;/form&gt; &lt;form action = \"http://localhost:8080\" id = fo1 &gt; &lt;input type = \"submit\" value = \"动态注册\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 4.7 DOM模型概念： 全称为Document Object Mobel文档对象模型，就是把文档中的标签，属性，文本，都转换为对象来管理。 Document 管理了所有的HTML文档内容 Document 是一种树结构的文档，有层级关系 Document 使所有的标签对象化 可以通过document访问所有的标签对象 方法： getElementById:根据id属性，获取标签对象 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script&gt; //需求：当用户点击校验按钮后，要获取输出框中的内容，然后验证其是否合法 // 验证的规则为，必须由字母，数字，下划线组成，且长度为5-12位 function onclickFun()&#123; //当我们要获取一个标签时，一定要先获取其对象 var usernameObj = document.getElementById(\"username\"); // &#123;Object HTMLInputElement&#125;它就是dom对象 var usernameText = usernameObj.value; // 使用正则表达式，验证字符串是否符合规则 var patt = /^\\w&#123;5,12&#125;$/; /* test()方法用来测试某个字符串，是不是匹配我的规则 匹配就反回true,否则返回false */ if(patt.test(usernameText))&#123; alert(\"用户名合法\"); &#125;else&#123; alert(\"用户名非法\"); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form&gt; 用户名：&lt;input type = \"text\" id = \"username\" value = \"用户名\"&gt; &lt;button onclick=\"onclickFun()\"&gt;校验&lt;/button&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script&gt; //需求：当用户点击校验按钮后，要获取输出框中的内容，然后验证其是否合法 // 验证的规则为，必须由字母，数字，下划线组成，且长度为5-12位 function onclickFun()&#123; //当我们要获取一个标签时，一定要先获取其对象 var usernameObj = document.getElementById(\"username\"); // &#123;Object HTMLInputElement&#125;它就是dom对象 var usernameText = usernameObj.value; // 使用正则表达式，验证字符串是否符合规则 var patt = /^\\w&#123;5,12&#125;$/; /* test()方法用来测试某个字符串，是不是匹配我的规则 匹配就反回true,否则返回false */ var usernameSpanObj = document.getElementById(\"usernameSpan\"); if(patt.test(usernameText))&#123; usernameSpanObj.innerHTML=\"用户名合法\"; &#125;else&#123; usernameSpanObj.innerHTML=\"用户名非法\"; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form&gt; 用户名：&lt;input type = \"text\" id = \"username\" value = \"用户名\"&gt; &lt;span id = \"usernameSpan\" style = \"color:red;\"&gt;&lt;/span&gt; &lt;button onclick=\"onclickFun()\"&gt;校验&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; getElementsByName(elementName):是根据指定的name属性查询返回多个标签对象集合 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type = \"text/javascript\"&gt; //全选 function checkAll()&#123; //document.getElementsByName;是根据指定的name属性查询返回多个标签对象集合 //这个集合的操作同数组一样 //集合中每个元素都是dom对象 //这个集合的缘啊苏顺序是他们在html页面中从上到下的顺序 var hobbies = document.getElementsByName(\"hobby\"); // checked 表示复选框的选中状态，选中为true，不选中为false，该属性可读可写 for( var i = 0; i &lt; hobbies.length;i++)&#123; hobbies[i].checked = true; &#125; &#125;//全不选 function checkNo()&#123; var hobbies = document.getElementsByName(\"hobby\"); for( var i = 0; i &lt; hobbies.length;i++)&#123; hobbies[i].checked = false; &#125; &#125;//反选 function checkReverse()&#123; var hobbies = document.getElementsByName(\"hobby\"); for( var i = 0; i &lt; hobbies.length;i++)&#123; if(hobbies[i].checked == true)&#123; hobbies[i].checked = false; &#125;else&#123; hobbies[i].checked = true; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; 兴趣爱好： &lt;input type = \"checkbox\" name = \"hobby\" value = \"cpp\"&gt;c++ &lt;input type = \"checkbox\" name = \"hobby\" value = \"java\"&gt;java &lt;input type = \"checkbox\" name = \"hobby\" value = \"js\"&gt;javaScript &lt;br/&gt; &lt;button onclick=\"checkAll()\"&gt;全选&lt;/button&gt; &lt;button onclick=\"checkNo()\"&gt;全不选&lt;/button&gt; &lt;button onclick=\"checkReverse()\"&gt;反选&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; getElementsByTagName(tagName) 按照指定标签名进行查询，并返回集合 这个集合的操作和数组一样 集合中都是dom对象 集合中元素顺序，是他们在html页面中从上到下的顺序 document.createElement(tagName) 方法：通过给定的标签名，创建一个标签对象，tagName是要创建的标签名 注： document对象的三个查询方法，如果有id属性，优先使用getElementById方法查询，其次getElementsByName，再次为getElementsByTagName 以上三个方法，一定要在页面加载完成后，才能查询到标签对象 4.8 节点的常用属性和方法 节点就是标签对象 方法： getElementsByTagName()方法，获取当前节点的指定标签名孩子节点 appendChild(oChildNode)方法，可以添加一个子节点，ochildNode是要添加的孩子节点 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type = \"text/javascript\"&gt; window.onload = function()&#123; // 使用js代码创建html标签，并显示在页面上 // 标签的内容为，&lt;div&gt;lalala&lt;/div&gt; var divObj = document.createElement(\"div\"); //在内存中 divObj.innerHTML = \"lalala\"; //还是只在内存中 document.body.appendChild(divObj); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 属性： childNodes:当前节点的所有子节点 firstChild：获取当前节点的第一个子节点 lastChile：获取当前节点的最后一个子节点 parentNode：获取当前节点的父亲节点 nextSibling：获取当前节点的下一个节点 previousSibling：获取当前节点的上一个节点 classNode：用于获取或设置标签的class属性值 innerHtml：表示获取/设置起始标签和结束标签中的内容 innerText：表示获取/设置起始标签和结束标签中的文本","categories":[{"name":"后端学习","slug":"后端学习","permalink":"http://moersuo.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"},{"name":"JavaWeb","slug":"后端学习/JavaWeb","permalink":"http://moersuo.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://moersuo.github.io/tags/JavaWeb/"}]},{"title":"剑指offer11：旋转数组的最小数字","slug":"剑指offer11：旋转数组的最小数字","date":"2020-10-21T08:01:50.000Z","updated":"2020-10-21T09:19:05.129Z","comments":true,"path":"2020/10/21/剑指offer11：旋转数组的最小数字/","link":"","permalink":"http://moersuo.github.io/2020/10/21/%E5%89%91%E6%8C%87offer11%EF%BC%9A%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/","excerpt":"","text":"题目： 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 示例：12输入：[2,2,2,0,1]输出：0 法一：笨法子，排序思路： 使用任意排序方法，再返回最小值 本次使用冒泡做例子 代码：12345678910111213141516171819class Solution &#123; public int minArray(int[] numbers) &#123; boolean flag = false; for(int i = 0; i &lt; numbers.length-1;i++)&#123; flag = false; for(int j = numbers.length - 1;j &gt;i;j--)&#123; int temp; if(numbers[j] &lt;numbers[j-1])&#123; temp = numbers[j]; numbers[j] = numbers[j-1]; numbers[j-1] = temp; flag = true; &#125; &#125; if(!flag) break; &#125; return numbers[0]; &#125;&#125; 复杂度： 根据你的排序算法而定，冒泡的时间复杂度为O(n*n) 法二：二分法思路： 排序数组的查找问题首先考虑使用 二分法 解决，其可将 遍历法 的 线性级别 时间复杂度降低至 对数级别 。 初始化：声明left，right为数组左右两端点 循环二分：设mid=left+(right-left)/2 当numbers[mid] &lt; numbers[right]时，最小值必然不在right右侧，right = mid 当numbers[mid] &gt; numbers[right]时，最小值必然不等于mid，且不在mid左侧，left = mid+1 当numbers[mid] = numbers[right]时，暴力使用right–排除干扰项 返回值：当left=right时跳出循环，返回left即可 代码：12345678910111213141516class Solution &#123; public int minArray(int[] numbers) &#123; int left = 0, right = numbers.length - 1; while(left &lt; right)&#123; int mid = (left+(right-left)/2); if(numbers[mid] &lt; numbers[right])&#123; right = mid; &#125;else if(numbers[mid] &gt; numbers[right]) &#123; left = mid+1; &#125;else if(numbers[mid] == numbers[right])&#123; right--; &#125; &#125; return numbers[left]; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"剑指offer","slug":"算法/剑指offer","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://moersuo.github.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"剑指offer10-2：青蛙跳台阶 ","slug":"剑指offer10-2：青蛙跳台阶","date":"2020-10-20T06:12:57.000Z","updated":"2020-10-20T07:33:08.869Z","comments":true,"path":"2020/10/20/剑指offer10-2：青蛙跳台阶/","link":"","permalink":"http://moersuo.github.io/2020/10/20/%E5%89%91%E6%8C%87offer10-2%EF%BC%9A%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6/","excerpt":"","text":"题目： 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例： 输入：n = 7输出：21 提示： 0 &lt;= n &lt;= 100` 法一：递归思路： 此类求多种可能性的问题一般都有递推性质 设跳上台阶有f（n）种跳法。在所有跳法中，最后一步只存在两种可能：跳上1级或2级台阶 当为1级台阶时：剩n-1个台阶，此时共f（n-1）种跳法(一级台阶一种跳法) 当为2级台阶时：剩n-2个台阶，此时共f（n-2）种跳法（两级台阶两种跳法） f（n）为以上两种情况之和，即f（n）=f（n-1）+f（n-2），等同于斐波那契数列，转换为求斐波那契数列第n项的值，唯一的不同在于起始值不同。 青蛙跳台阶：f（0）=1，f（1）=1，f（2）=2； 斐波那契：f（0）=1，f（1）=1，f（2）=2； 代码：12345678910class Solution &#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); public int numWays(int n) &#123; if(n==0) return 1; if(n==1) return 1; if(n==2) return 2; if(!map.containsKey(n)) map.put(n,(numWays(n-1)+numWays(n-2))%1000000007); return map.get(n); &#125;&#125; 法二：动态规划代码：12345678910111213141000000007class Solution &#123; public int numWays(int n) &#123; if(n == 0) return 1; if(n == 1) return 1; if(n == 2) return 2; int prev = 1,curr=2; for(int i = 3;i&lt;=n;i++)&#123; int sum = (prev+curr)%1000000007; prev = curr; curr = sum; &#125; return curr; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"剑指offer","slug":"算法/剑指offer","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://moersuo.github.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"剑指offer10-1：斐波那契数列","slug":"剑指offer10-1：斐波那契数列","date":"2020-10-18T07:01:07.000Z","updated":"2020-10-18T08:41:26.465Z","comments":true,"path":"2020/10/18/剑指offer10-1：斐波那契数列/","link":"","permalink":"http://moersuo.github.io/2020/10/18/%E5%89%91%E6%8C%87offer10-1%EF%BC%9A%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/","excerpt":"","text":"题目： 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下： 12F(0) &#x3D; 0, F(1) &#x3D; 1F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 0 &lt;= n &lt;= 100 示例： 输入：n = 15输出：610 法一：递归思路： 当看到这种定义时，我们的第一反应便是递归结构,但由于重复计算，结果很容易超时 123456class Solution &#123; public int fib(int n) &#123; if(n &lt; 2) return n; return fib(n - 1) + fib(n - 2); &#125;&#125; 我们尝试将计算过的值使用map储存起来，每次计算时查看map，若mao中有值便直接从map中取，若map中没有便将结果存入map 12345678class Solution &#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); public int fib(int n) &#123; if(n &lt; 2) return n; if(!map.containsKey(n)) map.put(n,(fib(n - 1) + fib(n - 2)) % 1000000007); return map.get(n); &#125;&#125; 法二：动态规划 状态定义： 设 dp 为一维数组，其中 dp[i] 的值代表 斐波那契数列第 i个数字 。 转移方程： dp[i] = dp[i - 1] + dp[i - 2],即对应数列定义f(n) = f(n - 1) + f(n - 2) 初始状态： dp[0] = 0, dp[1] =1 ，初始化前两个数字 返回值：dp[n] 1234567891011121314class Solution &#123; public int fib(int n) &#123; if(n == 0) return 0; if(n == 1) return 1; int[] dp = new int[n+1]; dp[0] = 0; dp[1] = 1; for(int i=2;i&lt;=n;i++)&#123; dp[i] = dp[i-1] + dp[i-2]; dp[i] %= 1000000007; &#125; return dp[n]; &#125;&#125; 优化：避免创建dp数组，当前状态只和前两个状态有关，维持两个状态即可，将空间复杂度降为O（1） 1234567891011int fib(int n) &#123; if (n == 2 || n == 1) return 1; int prev = 1, curr = 1; for (int i = 3; i &lt;= n; i++) &#123; int sum = prev + curr; prev = curr; curr = sum; &#125; return curr;&#125; 复杂度分析： 时间复杂度O(1) 空间复杂的O(1)","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"剑指offer","slug":"算法/剑指offer","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://moersuo.github.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"注解","slug":"注解","date":"2020-10-16T07:00:59.000Z","updated":"2020-10-18T06:08:43.384Z","comments":true,"path":"2020/10/16/注解/","link":"","permalink":"http://moersuo.github.io/2020/10/16/%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"一. 什么是注解1.1 作用： 不是程序本身，可以对程序作出解释（等同注释） 可以被其他程序（如编译器等）读取 1.2 格式： 注释是以“@注释名”在代码中存在的，还可以添加一些参数值，如：@SuppressWarnings(value=”unchecked”) 1.3 位置： 可以附加在package,class,method,field等上面，相当于给他们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问。 二.内置注解 @Override: 定义在java.lang.Override中，此注释只适用于修辞方法，表示一个方法声明打算重写超类中的另一个方法声明 @Deprecated: 定义在java.lang.Deprecated中，此注释可以用于修辞方法，属性，类，表示不鼓励程序员使用这样的元素，通常是因为它很危险或者存在更好的选择（已淘汰） @SuppressWarnings： 定义在java.lang.SuppressWarnings中，用来抑制编译时的警告信息。 与前两个注释不同的是，此注解需要添加一个参数才能正确使用，这些参数均为已定义好的，选择使用即可。 @SuppressWarnings(“all”) @SuppressWarnings(“unchecked”) @SuppressWarnings(“unchecked”,”deprecation”) 三. 元注解 元注解的作用就是负责注解其他注解，java定义了四个标准的meta-annotation类型，他们被用来提供对其他annotation类型作说明 这些类型和他们所支持的类在java.lang.annotation包中可以找到. @Target,@Retention,@Documented,@Inherited @Target: 用于描述注解的使用范围 @Retention: 表示需要在什么级别保存该注释信息，用于描述注解的生命周期（SOURCE&lt;CLASS&lt;RUNTIME） SOURCE：只在本编译单元的编译过程中保留，并不写入Class文件中 CLASS：在编译的过程中保留并且会写入Class文件中，但是JVM在加载类的时候不需要将其加载为运行时可见的（反射可见）的注解 RUNTIME：在编译过程中保留，会写入Class文件，并且JVM加载类的时候也会将其加载为反射可见的注解 @Document：说明该注解将被包含在javadoc中 @Inherited：说明子类可以继承父类中的该注解 1234567//@LaAnnotation被限定只能使用在类、接口或方法上面@Target(value = &#123;ElementType.TYPE,ElementType.METHOD&#125;)public @interface LaAnnotation &#123; String name(); int age() default 18; int[] La();&#125; 四. 自定义注解 使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口 @interface用来声明一个注解，格式：public@interface注解名（定义内容） 注解中定义的为注解类型元素，()不是定义方法参数的地方，也不能在括号中定义任何参数，仅仅只是一个特殊的语法； 返回值的类型就是元素的类型（返回值只能是基本类型，class，String，enum） 可以通过default来声明默认值 如果只有一个参数成员，一般参数名为value 注解元素必须要有值，我们定义注解元素时，经常用空字符串，0作为默认值 12345public @interface LaAnnotation &#123; public String name(); int age() default 1; int[] La();&#125;","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://moersuo.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"编程语言","slug":"计算机基础/编程语言","permalink":"http://moersuo.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://moersuo.github.io/tags/Java/"}]},{"title":"剑指offer09：用两个栈实现队列","slug":"剑指offer09：用两个栈实现队列","date":"2020-10-16T02:02:37.000Z","updated":"2020-10-16T04:48:37.441Z","comments":true,"path":"2020/10/16/剑指offer09：用两个栈实现队列/","link":"","permalink":"http://moersuo.github.io/2020/10/16/%E5%89%91%E6%8C%87offer09%EF%BC%9A%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/","excerpt":"","text":"题目： 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 示例： 输入：[“CQueue”,”appendTail”,”deleteHead”,”deleteHead”][[],[3],[],[]]输出：[null,null,3,-1] 输入：[“CQueue”,”deleteHead”,”appendTail”,”appendTail”,”deleteHead”,”deleteHead”][[],[],[5],[2],[],[]]输出：[null,-1,null,null,5,2] 提示： 1 &lt;= values &lt;= 10000最多会对 appendTail、deleteHead 进行 10000 次调用 法一：使用双Stack模拟插入和删除操作思路: 根据题意，首先想到的便是用两个栈分别模拟在队列尾部插入整数和队列头部删除整数 因为栈是先进后出，而队列是先进先出。所以我们可以使用将插入栈压入删除栈的办法来模拟，队列的添加删除 在appendTail方法中，正常将元素压入栈1 在deleteHead方法中，判断删除栈是否为空 为空，循环将插入栈的元素压入删除栈中，直到插入栈为空时停止 当删除栈不为空时，返回一个弹出的栈顶元素；或删除栈为空，但插入栈也为空，没有元素可插入，此时返回 -1. 代码：123456789101112131415161718192021222324252627class CQueue &#123; public Stack&lt;Integer&gt; stack1; public Stack&lt;Integer&gt; stack2; public CQueue() &#123; stack1 = new Stack&lt;&gt;(); // 插入栈 stack2 = new Stack&lt;&gt;(); //删除栈 &#125; public void appendTail(int value) &#123; stack1.push(value); &#125; public int deleteHead() &#123; if(stack2.isEmpty())&#123; while(!stack1.isEmpty())&#123; stack2.push(stack1.pop()); &#125; &#125; return stack2.isEmpty() ? -1 : stack2.pop(); &#125;&#125;/** * Your CQueue object will be instantiated and called as such: * CQueue obj = new CQueue(); * obj.appendTail(value); * int param_2 = obj.deleteHead(); */ 法二：使用LinkedList模拟双栈操作思路： 与双栈基本类似，区别在deleteHead思路不同 当删除栈不为空时，返回弹出的栈顶元素 当插入栈为空时，返回 -1 当插入栈不为空时，将插入栈压入删除栈，直到插入栈为空时截止 返回删除栈弹出的栈顶元素 代码：12345678910111213141516class CQueue &#123; LinkedList&lt;Integer&gt; l1, l2; public CQueue() &#123; l1 = new LinkedList&lt;Integer&gt;(); l2 = new LinkedList&lt;Integer&gt;(); &#125; public void appendTail(int value) &#123; l1.addLast(value); &#125; public int deleteHead() &#123; if(!l2.isEmpty()) return l2.removeLast(); if(l1.isEmpty()) return -1; while(!l1.isEmpty()) l2.addLast(l1.removeLast()); return l2.removeLast(); &#125; 两者复杂度分析： 时间复杂度：O(1)，插入为O(1)操作，删除 只需要完成n个元素的倒序，均摊下来为O(1) 空间复杂度：O(N)","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"剑指offer","slug":"算法/剑指offer","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://moersuo.github.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"MySQL版本相关问题","slug":"MySQL版本相关问题","date":"2020-10-14T01:04:03.000Z","updated":"2020-10-14T01:15:52.011Z","comments":true,"path":"2020/10/14/MySQL版本相关问题/","link":"","permalink":"http://moersuo.github.io/2020/10/14/MySQL%E7%89%88%E6%9C%AC%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/","excerpt":"","text":"一.com.mysql.cj.jdbc.Driver与com.mysql.jdbc.Driver区别:com.mysql.cj.jdbc.Driver是mysql-connector-java 6 中的特性，相比mysql-connector-java 5 多了一个时区：serverTimezone 报错方式: Loading class com.mysql.jdbc.Driver&#39;. This is deprecated. The new driver class iscom.mysql.cj.jdbc.Driver’. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.Exception in thread “main” java.sql.SQLException: The server time zone value ‘�й���׼ʱ��’ is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the ‘serverTimezone’ configuration property) to use a more specifc time zone value if you want to utilize time zone support. 解决方法： 将com.mysql.jdbc.driver替换为com.mysql.cj.jdbc.driver 在url配置中加入serverTimezone=GMT%2B8，如果前面有其他配置使用&amp;连接","categories":[{"name":"后端学习","slug":"后端学习","permalink":"http://moersuo.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"},{"name":"数据库","slug":"后端学习/数据库","permalink":"http://moersuo.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://moersuo.github.io/tags/MySQL/"}]},{"title":"JDBC","slug":"JDBC","date":"2020-10-13T08:34:34.000Z","updated":"2020-10-15T14:17:51.004Z","comments":true,"path":"2020/10/13/JDBC/","link":"","permalink":"http://moersuo.github.io/2020/10/13/JDBC/","excerpt":"","text":"一.概述1.什么是JDBCJDBC(Java Database Connectivity)是一个独立于特定数据库管理系统（DBMS）、通用的SQL数据库存取和操作的公共接口（一组API），定义了用来访问数据库的标准Java类库，使用这个类库可以以一种标准的方法、方便地访问数据库资源 JDBC为访问不同的数据库提供了一种统一的途径，为开发者屏蔽了一些细节问题。 2.组成 面向应用的API：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。 面向数据库的API：Java Driver API，供开发商开发数据库驱动程序用。 3.JDBC编写步骤 加载与注册驱动 URl 获取连接 执行增删改查 释放资源 二.初识JDBC案例1.1使用statement的增删改12345678910111213141516171819202122232425262728293031323334package mysql;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;public class TestConnection1 &#123; public static void main(String[] args) throws SQLException, ClassNotFoundException &#123; //DriverManager.registerDriver(new Driver()); 注册驱动，不推荐使用 //1.加载驱动 Class.forName(\"com.mysql.cj.jdbc.Driver\"); //2.获取连接 Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost/数据库名?serverTimezone=GMT%2B8\",\"账户名\",\"密码\"); System.out.println(\"连接成功\"); //3.执行增删改查 //3.1编写sql语句 //删除 // String sql = \"delete from beauty where id = 9\"; //更新 // String sql = \"update beauty set name = 'lalala' where id = 7\"; //增加 String sql = \"insert into beauty values(null,'lalala','女','1999-1-1','110',null,'3')\"; //3.2 获取执行sql语句的命令对象 Statement statement = connection.createStatement(); //3.3使用sql对象执行sql语句 int update = statement.executeUpdate(sql); //3.4处理执行结果 System.out.println(update&gt;0?\"success\":\"failure\"); //4.关闭连接 statement.close(); connection.close(); &#125;&#125; 案例1.2使用statement的查询123456789101112131415161718192021222324252627282930313233343536package mysql;import java.sql.*;public class TestConnection2&#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; //1.加载驱动 Class.forName(\"com.mysql.cj.jdbc.Driver\"); //固定写法 //2.用户信息和url String url = \"jdbc:mysql://localhost:3306/数据库名?useUnicode=true&amp;characterEncoding=utf8&amp;useSSl=true&amp;serverTimezone=GMT%2B8\"; String username = \"账户名\"; String password = \"密码\"; //3.获取与数据库的连接,Connection代表数据库 Connection connection = DriverManager.getConnection(url,username,password); //4.执行增删改查 //4.1获取执行sql的命令对象statement Statement statement = connection.createStatement(); ////4.2执行sql语句 String sql = \"Select * from beauty\"; ResultSet resultSet = statement.executeQuery(sql); //返回的结果集 //statement.executeQuery(sql);//执行查询语句 //statement.executeUpdate(sql);//执行增删改语法，返回受影响行数 //statement.execute(sql);//执行任何sql语句 while(resultSet.next())&#123; System.out.println(\"id=\"+resultSet.getObject(\"id\")); System.out.println(\"name=\"+resultSet.getObject(\"name\")); System.out.println(\"sex=\"+resultSet.getObject(\"sex\")); System.out.println(\"------------------------\"); &#125; //5.释放连接 resultSet.close(); statement.close(); connection.close(); &#125;&#125; 注：1.useUnicode=true&amp;characterEncoding=utf8作用：指定字符的编码，解码格。例如mysql数据库用的是gbk编码，而项目数据库用的是utf-8编码 2.useSSl=true或falseMySQL在高版本需要指明是否进行SSL连接。 SSL协议提供服务主要： 认证用户服务器，确保数据发送到正确的服务器； . 加密数据，防止数据传输途中被窃取使用； 维护数据完整性，验证数据在传输过程中是否丢失； 3.serverTimezone=GMT%2B8mysql-connector-java 6 中的特性，相比mysql-connector-java 5 多了一个时区：serverTimezone serverTimezone=GMT%2B8 //指定时区为北京时间东八区 4.为什么不使用注册驱动通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类都包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例。 注：使用DriverManager.registerDriver(com.mysql.cj.jdbc.Driver)来注册驱动 JDBC常见APIJDBC API是一系列的接口，它统一和规范了应用程序与数据库的连接、执行SQL语句，并到得到返回结果等各类操作。声明在java.sql与javax.sql包中。 DriverManager 驱动管理类​ registDriver(Driver对象):注册驱动（不推荐使用） ​ getConnection(url,user,pwd):获取连接 Connection 连接对象接口​ createStatement():生产命令对象 ​ prepareStatement(sql):生产预编译命令对象 Statement 命令对象接口​ executeUpdate(sql):执行增删改语句，返回受影响的行数 ​ executeQuery(sql):执行查询语句，返回结果集 ​ execute(sql):执行任意sql语句，返回boolean PrepareStatement预编译命令对象接口​ executeUpdate(sql):执行增删改语句，返回受影响的行数 ​ executeQuery(sql):执行查询语句，返回结果集 ​ execute(sql):执行任意sql语句，返回boolean ​ setXX(占位符索引，占位符的值):设置对应索引的占位符的值，类型为Object类型 ResultSet结果对象接口​ next():下移一行，返回当前行是否有值 ​ previous():上移一行，返回当前是否有值 ​ getXX(列索引||列名||别名):返回对应列的值，接受类型为XX ​ getObject(列索引||列名||别名):返回对应列的值，接受类型为Object 三.获取连接（包含JDBC编写的前三步）1.加载驱动加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名 Class.forName(“com.mysql.cj.jdbc.Driver”); 注： java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。 在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现。 eg: Oracle的驱动：oracle.jdbc.driver.OracleDriver ，mySql的驱动： com.mysql.cj.jdbc.Driver 2.URL JDBC URL 向驱动程序提供个一个识别数据源的方法，根据URL先前载入的驱动程序便可以找到对应的数据源并且实现数据库连接。 JDBC URL的标准由三部分组成，各部分间用冒号分隔。 jdbc:子协议:名称 ，协议：JDBC URL中的协议总是jdbc 子协议：子协议用于标识一个数据库驱动程序 名称：一种标识数据库的方法。名称可以依不同的子协议而变化，用名称的目的是为了定位数据库提供足够的信息。包含主机名(对应服务端的ip地址)，端口号，数据库名 常见MySQL连接URL编写方式： jdbc:mysql://主机名称:mysql:服务端口号/数据库名称?参数=值&amp;参数=值 jdbc:mysql://localhost:3306/lalala?useUnicode=true&amp;characterEncoding=utf8 jdbc:mysql://localhost:3306/lalala?user=用户名&amp;password=密码 jdbc:mysql://localhost:3306/lalala 用户名和密码： user,password可以用“属性名=属性值”方式告诉数据库 eg：String username = “账户名” String password = “密码”; 可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接 3.连接方式：连接方式112345678910111213141516public void testConnection1() &#123; try &#123; //1.数据库连接的4个基本要素： String url = \"jdbc:mysql://localhost:3306/test\"; String user = \"root\"; String password = \"123456\"; String driverClass= \"com.mysql.cj.jdbc.Driver\"; //2.加载驱动 Class.forName(driverName); //3.获取连接 Connection connection = DriverManager.getConnection(url, user, password); System.out.println(connection); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 连接方式212345678910111213141516171819public void testConnection2() throws Exception &#123; //1.加载配置文件 InputStream is = ConnectionTest.class.getClassLoader().getResourceAsStream(\"jdbc.properties\"); Properties pros = new Properties(); pros.load(is); //2.读取配置信息 String user = pros.getProperty(\"user\"); String password = pros.getProperty(\"password\"); String url = pros.getProperty(\"url\"); String driverClass = pros.getProperty(\"driverClass\"); //3.加载驱动 Class.forName(driverClass); //4.获取连接 Connection connection =DriverManager.getConnection(url,user,password); System.out.println(connection); &#125; 配置文件在工程的src目录下建立：jdbc.properties 1234user&#x3D;rootpassword&#x3D;123456url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;lalaladriverClass&#x3D;com.mysql.cj.jdbc.Driver 为什么使用配置文件： 实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码 如果修改了配置信息，省去重新编译的过程。 四.使用PreparedStatement实现CRUD操作4.1 操作和访问数据库 数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。一个数据库连接就是一个Socket连接。 在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式： Statement：用于执行静态 SQL 语句并返回它所生成结果的对象。 PrepatedStatement：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。 CallableStatement：用于执行 SQL 存储过程 4.2 使用Statement操作数据表 通过调用 Connection 对象的 createStatement() 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。 Statement 接口中定义了下列方法用于执行 SQL 语句： int update = statement.executeUpdate(sql); 执行更新操作INSERT、UPDATE、DELETE ResultSet resultSet = statement.executeQuery(sql); 执行查询操作SELECT 弊端： 存在拼串操作，繁琐 eg: 1String sql = \"SELECT user,password FROM user_table WHERE USER = '\" + userName + \"' AND PASSWORD = '\" + password 存在SQL注入问题 解决方法：对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了 4.3 JDBC连接的工具类功能 获取连接 释放资源 样例：123456789101112131415161718192021222324252627282930313233343536373839public class JDBCUtile&#123; //获取可用的连接对象 static String user static String password static String url static String driverClass try&#123; Properties info = new Properties; info.load(new FileInputStream(\"src\\\\jdbc.properties\")); user = pros.getProperty(\"user\"); password = pros.getProperty(\"password\"); url = pros.getProperty(\"url\"); driverClass = pros.getProperty(\"driverClass\"); Class.forName(driverClass); &#125;catch(Exception e)&#123; throw new RuntimeException(); &#125; public static Connection getConnection() throws Exception&#123; return DriverManager.getConnection(url,user,password); &#125; //释放资源 public static void close(ResultSet set,Statement statement,Connection connection)&#123; try&#123; if(set != null)&#123; set.close(); &#125; if(statament != null)&#123; statement.close(); &#125; if(connection != null)&#123; connection.close(); &#125; &#125;catch&#123; throw new RuntimeException(); &#125; &#125;&#125; 4.4 使用PreparedStatement简介： PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句 可以通过调用 Connection 对象的 preparedStatement(String sql) 方法获取 PreparedStatement 对象 PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值 相对Statement的优势： 代码的可读性和可维护性 更好的性能，预编译语句可被重复调用，储存在缓存中，节省反复编译的时间。 防止 SQL 注入 实现增、删、改操作1234567891011121314151617181920212223242526//通用的增、删、改操作（体现一：增、删、改 ； 体现二：针对于不同的表） public int update(String sql,Object ... args)&#123; Connection conn = null; PreparedStatement ps = null; try &#123; //1.获取数据库的连接 conn = JDBCUtils.getConnection(); //2.获取PreparedStatement的实例 (或：预编译sql语句) ps = conn.prepareStatement(sql); //3.填充占位符 for(int i = 0;i &lt; args.length;i++)&#123; ps.setObject(i + 1, args[i]); &#125; int update = statement.executeUpdate(); return update; //4.执行sql语句 ps.execute(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; //5.关闭资源 JDBCUtils.close(conn, ps); &#125; &#125; 实现查询1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 通用的针对于不同表的查询:返回一个对象 public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz, String sql, Object... args) &#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; // 1.获取数据库连接 conn = JDBCUtils.getConnection(); // 2.预编译sql语句，得到PreparedStatement对象 ps = conn.prepareStatement(sql); // 3.填充占位符 for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; // 4.执行executeQuery(),得到结果集：ResultSet rs = ps.executeQuery(); // 5.得到结果集的元数据：ResultSetMetaData ResultSetMetaData rsmd = rs.getMetaData(); // 6.1通过ResultSetMetaData得到columnCount,columnLabel；通过ResultSet得到列值 int columnCount = rsmd.getColumnCount(); if (rs.next()) &#123; T t = clazz.newInstance(); for (int i = 0; i &lt; columnCount; i++) &#123;// 遍历每一个列 // 获取列值 Object columnVal = rs.getObject(i + 1); // 获取列的别名:列的别名，使用类的属性名充当 String columnLabel = rsmd.getColumnLabel(i + 1); // 6.2使用反射，给对象的相应属性赋值 Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t, columnVal); &#125; return t; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 7.关闭资源 JDBCUtils.close(conn, ps, rs); &#125; return null;&#125; 4.5 ResultSet与ResultSetMetaDataResultSet 查询需要调用PreparedStatement 的 executeQuery() 方法，查询结果是一个ResultSet 对象 ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商提供实现 ResultSet 返回的实际上就是一张数据表。有一个指针指向数据表的第一条记录的前面。 ResultSet 对象维护了一个指向当前数据行的游标，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行。调用 next()方法检测下一行是否有效。若有效，该方法返回 true，且指针下移。相当于Iterator对象的 hasNext() 和 next() 方法的结合体。 当指针指向一行时, 可以通过调用 getXxx(int index) 或 getXxx(int columnName) 获取每一列的值。 例如: getInt(1), getString(“name”) 注意：Java与数据库交互涉及到的相关Java API中的索引都从1开始 ResultSetMetaData 可用于获取关于 ResultSet 对象中列的类型和属性信息的对象 ResultSetMetaData meta = rs.getMetaData(); getColumnName(int column)：获取指定列的名称 getColumnLabel(int column)：获取指定列的别名 getColumnCount()：返回当前 ResultSet 对象中的列数。 isNullable(int column)：指示指定列中的值是否可以为 null。 4.6 释放资源： 释放ResultSet, Statement,Connection 可以在finally中关闭，保证及时其他代码出现异常，资源也一定能被关闭。 ORM思想(object relational mapping) 一个数据表对应一个java类 表中的一条记录对应java类的一个对象 表中的一个字段对应java类的一个属性 五.JDBC事务处理： 数据一旦提交，则不可回滚 数据提交条件： 当一个连接对象被创建时，默认为自动提交事务：每次执行一个SQL语句时，如果执行成功，就会自动向数据库提交 关闭数据库连接时，数据就会自动提交：同一个事务的多个操作必须在同一连接下 JDBC程序中为了让多个SQL语句作为一个事务执行采取的方法： 调用Connection对象的setAutoCommit(false); 来取消自动提交事务 在所有SQl语句都成功执行后，调用Commit();方法提交事务 在出现异常时，调用rollback();方法回滚事务 注：若此时 Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态 setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。 案例：用户AA向用户BB转账10012345678910111213141516171819202122232425262728293031323334353637public void testJDBCTransaction() &#123; Connection conn = null; try &#123; // 1.获取数据库连接 conn = JDBCUtils.getConnection(); // 2.开启事务 conn.setAutoCommit(false); // 3.进行数据库操作 String sql1 = \"update user_table set balance = balance - 100 where user = ?\"; update(conn, sql1, \"AA\"); // 模拟网络异常 //System.out.println(10 / 0); String sql2 = \"update user_table set balance = balance + 100 where user = ?\"; update(conn, sql2, \"BB\"); // 4.若没有异常，则提交事务 conn.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); // 5.若有异常，则回滚事务 try &#123; conn.rollback(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125; finally &#123; try &#123; //6.恢复每次DML操作的自动提交功能 conn.setAutoCommit(true); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; //7.关闭连接 JDBCUtils.closeResource(conn, null, null); &#125; &#125; 其中，对数据库操作的方法为： 1234567891011121314151617181920//使用事务以后的通用的增删改操作（version 2.0）public void update(Connection conn ,String sql, Object... args) &#123; PreparedStatement ps = null; try &#123; // 1.获取PreparedStatement的实例 (或：预编译sql语句) ps = conn.prepareStatement(sql); // 2.填充占位符 for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; // 3.执行sql语句 ps.execute(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 4.关闭资源 JDBCUtils.closeResource(null, ps); &#125;&#125; 六.批量插入需要批量插入的情景 一个SQL语句的批量传参 多条SQL语句的批量处理 JDBC中批量插入方法 addBatch(String)：添加需要批量处理的SQL语句或是参数 executeBatch()：执行批量处理语句； clearBatch():清空缓存的数据 12345678910111213141516171819202122232425262728293031323334/*mysql服务器默认是关闭批处理的，我们需要通过一个参数，让mysql开启批处理的支持。* ?rewriteBatchedStatements=true 写在配置文件的url后面 */public void testInsert2() throws Exception&#123; long start = System.currentTimeMillis(); Connection conn = JDBCUtils.getConnection(); //1.设置为不自动提交数据 conn.setAutoCommit(false); String sql = \"insert into goods(name)values(?)\"; PreparedStatement ps = conn.prepareStatement(sql); for(int i = 1;i &lt;= 1000000;i++)&#123; ps.setString(1, \"name_\" + i); //1.“攒”sql ps.addBatch(); if(i % 500 == 0)&#123; //2.执行 ps.executeBatch(); //3.清空 ps.clearBatch(); &#125; &#125; //2.提交数据 conn.commit(); long end = System.currentTimeMillis(); System.out.println(\"花费的时间为：\" + (end - start)); JDBCUtils.closeResource(conn, ps); 七.数据库连接池7.1 JDBC数据库连接池的意义 在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤： 在主程序（如servlet、beans）中建立数据库连接 进行sql操作 断开数据库连接 这种模式开发，存在的问题: 普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。数据库的连接资源并没有得到很好的重复利用。若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。 对于每一次数据库连接，使用完后都得断开。否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。 这种开发不能控制被创建的连接对象数，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。 7.2 数据库连接池技术 数据库连接池的基本思想：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。 数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。 优点： 资源重用：避免频繁创建释放，减少系统消耗，提升稳定性。 更快的系统响应：由于数据库连接池在初始化时就创建了一些数据库连接在池中备用，因此在需要连接时，减少了响应时间。 更细腻的资源分配：在数据库连接池中可设置某一应用最大数据库连接数限制，避免独占资源。 避免数据库连接泄露：可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露 7.3 多种开源的数据库连接池 JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现： DBCP 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。速度相对c3p0较快，但因自身存在BUG，Hibernate3已不再提供支持。 C3P0 是一个开源组织提供的一个数据库连接池，速度相对较慢，稳定性还可以。hibernate官方推荐使用 Druid 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不确定是否有BoneCP快 DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池 DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。 注： 数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可 当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。 Druid案例：123456789101112131415import java.sql.Connection;import java.util.Properties;import javax.sql.DataSource;import com.alibaba.druid.pool.DruidDataSourceFactory;public class TestDruid &#123; public static void main(String[] args) throws Exception &#123; Properties pro = new Properties(); pro.load(TestDruid.class.getClassLoader().getResourceAsStream(\"druid.properties\")); DataSource ds = DruidDataSourceFactory.createDataSource(pro); Connection conn = ds.getConnection(); System.out.println(conn); &#125;&#125; 其中，src下的配置文件为：【druid.properties】 123456789url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test?rewriteBatchedStatements&#x3D;trueusername&#x3D;rootpassword&#x3D;123456driverClass&#x3D;com.mysql.cj.jdbc.DriverinitialSize&#x3D;10maxActive&#x3D;20maxWait&#x3D;1000filters&#x3D;wall 八.Apache-DBUtils实现CRUD操作8.1 简介 commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。 API: org.apache.commons.dbutils.QueryRunner org.apache.commons.dbutils.ResultSetHandler org.apache.commons.dbutils.DbUtils 8.2 DbUtils DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下： public static void close(…) throws java.sql.SQLException： DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。 8.3 QueryRunner类 该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。 QueryRunner类提供了两个构造器： 默认的构造器 需要一个 javax.sql.DataSource 来作参数的构造器 QueryRunner类的主要方法： 更新：public int update(Connection conn, String sql, Object… params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。 插入：public T insert(Connection conn,String sql,ResultSetHandler rsh, Object… params) throws SQLException：只支持INSERT语句 批处理： public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句 public T insertBatch(Connection conn,String sql,ResultSetHandler rsh,Object[][] params)throws SQLException：只支持INSERT语句 查询：public Object query(Connection conn, String sql, ResultSetHandler rsh,Object… params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。 测试 12345678910111213// 测试添加@Testpublic void testInsert() throws Exception &#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection(); String sql = \"insert into customers(name,email,birth)values(?,?,?)\"; int count = runner.update(conn, sql, \"何成飞\", \"he@qq.com\", \"1992-09-08\"); System.out.println(\"添加了\" + count + \"条记录\"); JDBCUtils.closeResource(conn, null);&#125; 12345678910111213// 测试删除@Testpublic void testDelete() throws Exception &#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection(); String sql = \"delete from customers where id &lt; ?\"; int count = runner.update(conn, sql,3); System.out.println(\"删除了\" + count + \"条记录\"); JDBCUtils.closeResource(conn, null);&#125; 8.4ResultSetHandler接口及实现类 该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。 ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。 接口的主要实现类： BeanHandler：将结果集中的第一行数据封装到一个对应的JavaBean实例中。 BeanListHandler：将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。 MapHandler：将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。 MapListHandler：将结果集中的每一行数据都封装到一个Map里，然后再存放到List ScalarHandler：查询单个值对象 ColumnListHandler：将结果集中某一列的数据存放到List中。 ArrayHandler：把结果集中的第一行数据转成对象数组。 ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。 测试 123456789101112131415161718/* * 测试查询:查询一条记录 * * 使用ResultSetHandler的实现类：BeanHandler */public void testQueryInstance() throws Exception&#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection(); String sql = \"select id,name,email,birth from customers where id = ?\"; // BeanHandler&lt;Customer&gt; handler = new BeanHandler&lt;&gt;(Customer.class); Customer customer = runner.query(conn, sql, handler, 23); System.out.println(customer); JDBCUtils.closeResource(conn, null);&#125; 12345678910111213141516171819/* * 测试查询:查询多条记录构成的集合 * * 使用ResultSetHandler的实现类：BeanListHandler */public void testQueryList() throws Exception&#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection(); String sql = \"select id,name,email,birth from customers where id &lt; ?\"; // BeanListHandler&lt;Customer&gt; handler = new BeanListHandler&lt;&gt;(Customer.class); List&lt;Customer&gt; list = runner.query(conn, sql, handler, 23); list.forEach(System.out::println); JDBCUtils.closeResource(conn, null);&#125; 123456789101112131415161718192021222324252627282930313233343536/* * 自定义ResultSetHandler的实现类 */public void testQueryInstance1() throws Exception&#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection(); String sql = \"select id,name,email,birth from customers where id = ?\"; ResultSetHandler&lt;Customer&gt; handler = new ResultSetHandler&lt;Customer&gt;() &#123; @Override public Customer handle(ResultSet rs) throws SQLException &#123; System.out.println(\"handle\");// return new Customer(1,\"Tom\",\"tom@126.com\",new Date(123323432L)); if(rs.next())&#123; int id = rs.getInt(\"id\"); String name = rs.getString(\"name\"); String email = rs.getString(\"email\"); Date birth = rs.getDate(\"birth\"); return new Customer(id, name, email, birth); &#125; return null; &#125; &#125;; Customer customer = runner.query(conn, sql, handler, 23); System.out.println(customer); JDBCUtils.closeResource(conn, null);&#125; 123456789101112131415161718192021222324/* * 如何查询类似于最大的，最小的，平均的，总和，个数相关的数据， * 使用ScalarHandler * */public void testQueryValue() throws Exception&#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection(); //测试一：// String sql = \"select count(*) from customers where id &lt; ?\";// ScalarHandler handler = new ScalarHandler();// long count = (long) runner.query(conn, sql, handler, 20);// System.out.println(count); //测试二： String sql = \"select max(birth) from customers\"; ScalarHandler handler = new ScalarHandler(); Date birth = (Date) runner.query(conn, sql, handler); System.out.println(birth); JDBCUtils.closeResource(conn, null);&#125; JDBC总结1234567891011121314151617181920212223242526272829303132333435public void testUpdateWithTx() &#123; Connection conn = null; try &#123; //1.获取连接的操作（ //① 手写的连接：JDBCUtils.getConnection(); //② 使用数据库连接池：C3P0;DBCP;Druid //2.对数据表进行一系列CRUD操作 //① 使用PreparedStatement实现通用的增删改、查询操作//增删改public void update(Connection conn,String sql,Object ... args)&#123;&#125;//查询 public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz,String sql,Object ... args)&#123;&#125; //② 使用dbutils提供的jar包中提供的QueryRunner类 //提交数据 conn.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); try &#123; //回滚数据 conn.rollback(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125;finally&#123; //3.关闭连接等操作 //① JDBCUtils.closeResource(); //② 使用dbutils提供的jar包中提供的DbUtils类提供了关闭的相关操作 &#125;&#125; 九.DAO及相关实现类 DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息。有时也称作：BaseDAO 作用：为了实现功能的模块化，更有利于代码的维护和升级。 【BaseDAO.java】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package com.atguigu.bookstore.dao;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.sql.Connection;import java.sql.SQLException;import java.util.List;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import org.apache.commons.dbutils.handlers.ScalarHandler;/** * 定义一个用来被继承的对数据库进行基本操作的Dao * * @author HanYanBing * * @param &lt;T&gt; */public abstract class BaseDao&lt;T&gt; &#123; private QueryRunner queryRunner = new QueryRunner(); // 定义一个变量来接收泛型的类型 private Class&lt;T&gt; type; // 获取T的Class对象，获取泛型的类型，泛型是在被子类继承时才确定 public BaseDao() &#123; // 获取子类的类型 Class clazz = this.getClass(); // 获取父类的类型 // getGenericSuperclass()用来获取当前类的父类的类型 // ParameterizedType表示的是带泛型的类型 ParameterizedType parameterizedType = (ParameterizedType) clazz.getGenericSuperclass(); // 获取具体的泛型类型 getActualTypeArguments获取具体的泛型的类型 // 这个方法会返回一个Type的数组 Type[] types = parameterizedType.getActualTypeArguments(); // 获取具体的泛型的类型· this.type = (Class&lt;T&gt;) types[0]; &#125; /** * 通用的增删改操作 * * @param sql * @param params * @return */ public int update(Connection conn,String sql, Object... params) &#123; int count = 0; try &#123; count = queryRunner.update(conn, sql, params); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return count; &#125; /** * 获取一个对象 * * @param sql * @param params * @return */ public T getBean(Connection conn,String sql, Object... params) &#123; T t = null; try &#123; t = queryRunner.query(conn, sql, new BeanHandler&lt;T&gt;(type), params); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return t; &#125; /** * 获取所有对象 * * @param sql * @param params * @return */ public List&lt;T&gt; getBeanList(Connection conn,String sql, Object... params) &#123; List&lt;T&gt; list = null; try &#123; list = queryRunner.query(conn, sql, new BeanListHandler&lt;T&gt;(type), params); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return list; &#125; /** * 获取一个但一值得方法，专门用来执行像 select count(*)...这样的sql语句 * * @param sql * @param params * @return */ public Object getValue(Connection conn,String sql, Object... params) &#123; Object count = null; try &#123; // 调用queryRunner的query方法获取一个单一的值 count = queryRunner.query(conn, sql, new ScalarHandler&lt;&gt;(), params); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return count; &#125;&#125; 【BookDAO.java】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.atguigu.bookstore.dao;import java.sql.Connection;import java.util.List;import com.atguigu.bookstore.beans.Book;import com.atguigu.bookstore.beans.Page;public interface BookDao &#123; /** * 从数据库中查询出所有的记录 * * @return */ List&lt;Book&gt; getBooks(Connection conn); /** * 向数据库中插入一条记录 * * @param book */ void saveBook(Connection conn,Book book); /** * 从数据库中根据图书的id删除一条记录 * * @param bookId */ void deleteBookById(Connection conn,String bookId); /** * 根据图书的id从数据库中查询出一条记录 * * @param bookId * @return */ Book getBookById(Connection conn,String bookId); /** * 根据图书的id从数据库中更新一条记录 * * @param book */ void updateBook(Connection conn,Book book); /** * 获取带分页的图书信息 * * @param page：是只包含了用户输入的pageNo属性的page对象 * @return 返回的Page对象是包含了所有属性的Page对象 */ Page&lt;Book&gt; getPageBooks(Connection conn,Page&lt;Book&gt; page); /** * 获取带分页和价格范围的图书信息 * * @param page：是只包含了用户输入的pageNo属性的page对象 * @return 返回的Page对象是包含了所有属性的Page对象 */ Page&lt;Book&gt; getPageBooksByPrice(Connection conn,Page&lt;Book&gt; page, double minPrice, double maxPrice);&#125; 【UserDAO.java】12345678910111213141516171819202122232425262728293031package com.atguigu.bookstore.dao;import java.sql.Connection;import com.atguigu.bookstore.beans.User;public interface UserDao &#123; /** * 根据User对象中的用户名和密码从数据库中获取一条记录 * * @param user * @return User 数据库中有记录 null 数据库中无此记录 */ User getUser(Connection conn,User user); /** * 根据User对象中的用户名从数据库中获取一条记录 * * @param user * @return true 数据库中有记录 false 数据库中无此记录 */ boolean checkUsername(Connection conn,User user); /** * 向数据库中插入User对象 * * @param user */ void saveUser(Connection conn,User user);&#125; 【BookDaoImpl.java】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.atguigu.bookstore.dao.impl;import java.sql.Connection;import java.util.List;import com.atguigu.bookstore.beans.Book;import com.atguigu.bookstore.beans.Page;import com.atguigu.bookstore.dao.BaseDao;import com.atguigu.bookstore.dao.BookDao;public class BookDaoImpl extends BaseDao&lt;Book&gt; implements BookDao &#123; @Override public List&lt;Book&gt; getBooks(Connection conn) &#123; // 调用BaseDao中得到一个List的方法 List&lt;Book&gt; beanList = null; // 写sql语句 String sql = \"select id,title,author,price,sales,stock,img_path imgPath from books\"; beanList = getBeanList(conn,sql); return beanList; &#125; @Override public void saveBook(Connection conn,Book book) &#123; // 写sql语句 String sql = \"insert into books(title,author,price,sales,stock,img_path) values(?,?,?,?,?,?)\"; // 调用BaseDao中通用的增删改的方法 update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(),book.getImgPath()); &#125; @Override public void deleteBookById(Connection conn,String bookId) &#123; // 写sql语句 String sql = \"DELETE FROM books WHERE id = ?\"; // 调用BaseDao中通用增删改的方法 update(conn,sql, bookId); &#125; @Override public Book getBookById(Connection conn,String bookId) &#123; // 调用BaseDao中获取一个对象的方法 Book book = null; // 写sql语句 String sql = \"select id,title,author,price,sales,stock,img_path imgPath from books where id = ?\"; book = getBean(conn,sql, bookId); return book; &#125; @Override public void updateBook(Connection conn,Book book) &#123; // 写sql语句 String sql = \"update books set title = ? , author = ? , price = ? , sales = ? , stock = ? where id = ?\"; // 调用BaseDao中通用的增删改的方法 update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(), book.getId()); &#125; @Override public Page&lt;Book&gt; getPageBooks(Connection conn,Page&lt;Book&gt; page) &#123; // 获取数据库中图书的总记录数 String sql = \"select count(*) from books\"; // 调用BaseDao中获取一个单一值的方法 long totalRecord = (long) getValue(conn,sql); // 将总记录数设置都page对象中 page.setTotalRecord((int) totalRecord); // 获取当前页中的记录存放的List String sql2 = \"select id,title,author,price,sales,stock,img_path imgPath from books limit ?,?\"; // 调用BaseDao中获取一个集合的方法 List&lt;Book&gt; beanList = getBeanList(conn,sql2, (page.getPageNo() - 1) * Page.PAGE_SIZE, Page.PAGE_SIZE); // 将这个List设置到page对象中 page.setList(beanList); return page; &#125; @Override public Page&lt;Book&gt; getPageBooksByPrice(Connection conn,Page&lt;Book&gt; page, double minPrice, double maxPrice) &#123; // 获取数据库中图书的总记录数 String sql = \"select count(*) from books where price between ? and ?\"; // 调用BaseDao中获取一个单一值的方法 long totalRecord = (long) getValue(conn,sql,minPrice,maxPrice); // 将总记录数设置都page对象中 page.setTotalRecord((int) totalRecord); // 获取当前页中的记录存放的List String sql2 = \"select id,title,author,price,sales,stock,img_path imgPath from books where price between ? and ? limit ?,?\"; // 调用BaseDao中获取一个集合的方法 List&lt;Book&gt; beanList = getBeanList(conn,sql2, minPrice , maxPrice , (page.getPageNo() - 1) * Page.PAGE_SIZE, Page.PAGE_SIZE); // 将这个List设置到page对象中 page.setList(beanList); return page; &#125;&#125; 【UserDaoImpl.java】123456789101112131415161718192021222324252627282930313233343536373839【Page.java】package com.atguigu.bookstore.dao.impl;import java.sql.Connection;import com.atguigu.bookstore.beans.User;import com.atguigu.bookstore.dao.BaseDao;import com.atguigu.bookstore.dao.UserDao;public class UserDaoImpl extends BaseDao&lt;User&gt; implements UserDao &#123; @Override public User getUser(Connection conn,User user) &#123; // 调用BaseDao中获取一个对象的方法 User bean = null; // 写sql语句 String sql = \"select id,username,password,email from users where username = ? and password = ?\"; bean = getBean(conn,sql, user.getUsername(), user.getPassword()); return bean; &#125; @Override public boolean checkUsername(Connection conn,User user) &#123; // 调用BaseDao中获取一个对象的方法 User bean = null; // 写sql语句 String sql = \"select id,username,password,email from users where username = ?\"; bean = getBean(conn,sql, user.getUsername()); return bean != null; &#125; @Override public void saveUser(Connection conn,User user) &#123; //写sql语句 String sql = \"insert into users(username,password,email) values(?,?,?)\"; //调用BaseDao中通用的增删改的方法 update(conn,sql, user.getUsername(),user.getPassword(),user.getEmail()); &#125;&#125; 【Page.java】123456789101112131415package com.atguigu.bookstore.beans;import java.util.List;/** * 页码类 * @author songhongkang * */public class Page&lt;T&gt; &#123; private List&lt;T&gt; list; // 每页查到的记录存放的集合 public static final int PAGE_SIZE = 4; // 每页显示的记录数 private int pageNo; // 当前页// private int totalPageNo; // 总页数，通过计算得到 private int totalRecord; // 总记录数，通过查询数据库得到 【User.java】123456789101112package com.atguigu.bookstore.beans;/** * 用户类 * @author songhongkang * */public class User &#123; private Integer id; private String username; private String password; private String email;","categories":[{"name":"后端学习","slug":"后端学习","permalink":"http://moersuo.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"},{"name":"数据库","slug":"后端学习/数据库","permalink":"http://moersuo.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://moersuo.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"生产者消费者模型","slug":"生产者消费者模型","date":"2020-10-08T09:31:50.000Z","updated":"2020-10-12T00:41:30.499Z","comments":true,"path":"2020/10/08/生产者消费者模型/","link":"","permalink":"http://moersuo.github.io/2020/10/08/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"概述：生产者消费者消费者模型是一种并发编程中的常见问题，基于等待/通知机制。其基本思想是有一块缓冲区作为仓库，生产者将产品放入枪库，消费者从仓库中取出产品。这个仓库就是一个阻塞队列，生产者生产的产品不直接给消费者消费而是给阻塞队列。这个阻塞队列目的是解决生产者消费者的强耦合。 解决的实际问题： 生产与消费的速度不匹配 软件开发过程中解耦，使生产者与消费者间的强耦合变成生产者和缓冲区，消费者与缓存区间的弱耦合 需要注意的点： 生产者生产的时候消费者不能消费 消费者消费的时候生产者不能生产 仓库即缓冲区为空时不能消费 缓冲区满时生产者不能生产 案例一：缓冲区法 建立继承自Thread的生产者类和消费者类，和只有产品编号字段及构造方法的产品类 构建缓冲区： 构建一个容器和它的容器计数器 构建加锁的生产者生产的push方法 构建加锁的消费者消费的pop方法 重写生产者及消费者的run方法，加入他们的构造方法 构建main方法，构建一个缓冲区类的container实例对象，并开启生产者和消费者线程 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package multithread.prodeuctor_consumer;// 测试生产者消费者模型--&gt;利用缓冲区解决：管程法//生产者，消费者，产品，缓冲区public class TestPc &#123; public static void main(String[] args) &#123; SynContainer container = new SynContainer(); new Productor(container).start(); new Consumer(container).start(); &#125;&#125;// 生产者class Productor extends Thread&#123; SynContainer container; public Productor(SynContainer container)&#123; this.container = container; &#125; //生产 @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; container.push(new Food(i)); System.out.println(\"生产了\"+i+\"号食物\"); &#125; &#125;&#125;// 消费者class Consumer extends Thread&#123; SynContainer container; public Consumer(SynContainer container)&#123; this.container = container; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"消费了--&gt;\"+container.pop().id+\"号食物\"); &#125; &#125;&#125;//产品class Food&#123; int id; //产品编号 public Food(int id) &#123; this.id = id; &#125;&#125;//缓冲区class SynContainer&#123; //需要一个容器大小 Food[] foods = new Food[10]; //容器计数器 int count = 0; //生产者放入产品 public synchronized void push(Food food)&#123; //如果容器满了，就需要等待消费者消费 while(count == foods.length)&#123; //通知消费者消费，生产等待 try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //如果容器未满，我们需要加入产品 foods[count] = food; count++; //可以通知消费者消费了 this.notifyAll(); &#125; public synchronized Food pop()&#123; //判断能否消费 while(count == 0)&#123; //等待生产者生产，消费者等待 try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //如果可以消费 count--; Food food = foods[count]; //吃完了，通知生产者生产 this.notifyAll(); return food; &#125;&#125; 案例二：信号灯法，标志位解决 构建生产者，消费者，产品类 构建产品类的字段节目，并建立标志位 构建演出与观看方法，标志位为真时表演–观看线程沉睡，为假时观看–表演线程沉睡，演出或观看结束时唤醒其他线程 构建测试类 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package multithread.prodeuctor_consumer;// 测试生产者，消费者问题2：信号灯法，标志位解决public class TestPc2 &#123; public static void main(String[] args) &#123; Tv tv = new Tv(); new actor(tv).start(); new audience(tv).start(); &#125;&#125;//生产者--&gt;演员class actor extends Thread&#123; Tv tv; public actor(Tv tv)&#123; this.tv = tv; &#125; @Override public void run()&#123; for (int i = 0; i &lt; 20; i++) &#123; if(i % 2 == 0)&#123; this.tv.play(\"风骚律师\"); &#125;else&#123; this.tv.play(\"广告\"); &#125; &#125; &#125;&#125;//消费者--&gt;观众class audience extends Thread&#123; Tv tv; public audience(Tv tv)&#123; this.tv = tv; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; this.tv.watch(); &#125; &#125;&#125;//产品--&gt;节目class Tv&#123; //演员录制节目，观众等待 T //观众观看，演员等待 F String program; //表演的节目 boolean flag = true; //表演 public synchronized void play(String program)&#123; if(!flag)&#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(\"演员表演了：\"+program); //通知观众观看 this.notifyAll();//通知唤醒 this.program = program; this.flag = !this.flag; &#125; //观看 public synchronized void watch()&#123; if(flag)&#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(\"观众观看了：\"+program); //通知演员表演 this.notifyAll(); this.flag = !this.flag; &#125;&#125;","categories":[{"name":"后端学习","slug":"后端学习","permalink":"http://moersuo.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"},{"name":"多线程","slug":"后端学习/多线程","permalink":"http://moersuo.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://moersuo.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"剑指offer06：从头到尾打印链表","slug":"剑指offer06：从头到尾打印链表","date":"2020-10-05T08:24:53.000Z","updated":"2020-10-05T09:10:38.341Z","comments":true,"path":"2020/10/05/剑指offer06：从头到尾打印链表/","link":"","permalink":"http://moersuo.github.io/2020/10/05/%E5%89%91%E6%8C%87offer06%EF%BC%9A%E4%BB%8E%E5%A4%B4%E5%88%B0%E5%B0%BE%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/","excerpt":"","text":"题目: 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例： 输入：head = [1,3,2]输出：[2,3,1] 限制： 0 &lt;= 链表长度 &lt;= 10000 法一：使用栈存储思路：当我们看到从尾到头反向输出时，便应该想到这是栈的的典型特征。根据这一特点，我们将使用栈将链表元素顺序倒置。从链表的第一个值开始，依次将每个值压入栈内，然后依次弹出栈内的元素并存储到数组中。 创建一个栈，用于储存链表每个节点的值 创建一个指针，指向链表头结点 当指针指向非空元素时，重复以下操作： 将指针指向的节点的值压入栈内 将指针移到当前节点的下一个节点 获得栈的大小size，创建一个大小为size的数组array 建立一个size次的for循环，每次从栈内弹出一个节点值，存入size中 返回array 代码：123456789101112131415161718192021222324/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int[] reversePrint(ListNode head) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); ListNode temp = head; while (temp != null) &#123; stack.push(temp.val); temp = temp.next; &#125; int size = stack.size(); int[] array = new int[size]; for (int i = 0; i &lt; size; i++) &#123; array[i] = stack.pop(); &#125; return array; &#125;&#125; 复杂度分析： 时间复杂度：O(n)。正向遍历一遍链表，然后从栈弹出全部节点，等于又反向遍历一遍链表。 空间复杂度：O(n)。额外使用一个栈存储链表中的每个节点。 法一.二:使用ArrayList存储思路相同，只不过容器换为ArrayList 代码：123456789101112131415public class Solution &#123; public int[] reversePrint(ListNode head) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while (head != null) &#123; list.add(head.val); head = head.next; &#125; int size = list.size(); int[] array = new int[size]; for (int i = 0; i &lt; size; i++) &#123; array[i] = list.get(size - i -1); &#125; return array; &#125;&#125; 法二：递归思路： 递推阶段： 每次传入 head.next ，以 head == null（即走过链表尾部节点）为递归终止条件，此时直接返回。 回溯阶段： 层层回溯时，将当前节点值加入列表，即tmp.add(head.val)。 最终，将列表 tmp 转化为数组 res ，并返回即可。 代码：123456789101112131415161718192021222324/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; ArrayList&lt;Integer&gt; temp = new ArrayList&lt;Integer&gt;(); public int[] reversePrint(ListNode head) &#123; recur(head); int[] array = new int[temp.size()]; for(int i = 0; i &lt; temp.size();i++)&#123; array[i] = temp.get(i); &#125; return array; &#125; void recur(ListNode head)&#123; if(head == null) return; recur(head.next); temp.add(head.val); &#125;&#125; 复杂度分析： 时间复杂度 O(N)： 遍历链表，递归 N次。 时间复杂度 O(N)： 遍历链表，递归 N次。","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"剑指offer","slug":"算法/剑指offer","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://moersuo.github.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"Leetcode题解09 回文数","slug":"Leetcode题解09-回文数","date":"2020-10-04T03:36:19.000Z","updated":"2020-10-04T06:40:37.014Z","comments":true,"path":"2020/10/04/Leetcode题解09-回文数/","link":"","permalink":"http://moersuo.github.io/2020/10/04/Leetcode%E9%A2%98%E8%A7%A309-%E5%9B%9E%E6%96%87%E6%95%B0/","excerpt":"","text":"Leetcode题解09 ：回文数题目： 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例： 输入: 121输出: true 输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。 官方法一：反转一半数字思路： 映入脑海的第一个想法便是将整个数字反转，再与原数字比较，如果他们相同则数字为回文数，但这可能会使反转后的数字大于int.max,产生整数溢出问题。 由此我们可以考虑反转整数的一半，回文数的后半部分反转后应该与前半部分相等。 首先处理临界问题 对于数字 1221，如果执行 1221 % 10，我们将得到最后一位数字 1，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以 10 的余数，122 % 10 = 2，就可以得到倒数第二位数字。如果我们把最后一位数字乘以 10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了我们想要的反转后的数字。如果继续这个过程，我们将得到更多位数的反转数字。 判断反转数字是否达到原始数字的一半：由于整个过程我们不断将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于或等于反转后的数字时，就意味着我们已经处理了一半位数的数字了。若出现入1321这样的情况，则非回文数，不影响结果。 代码:123456789101112131415161718192021222324class Solution &#123;public: bool isPalindrome(int x) &#123; // 特殊情况： // 如上所述，当 x &lt; 0 时，x 不是回文数。 // 同样地，如果数字的最后一位是 0，为了使该数字为回文， // 则其第一位数字也应该是 0 // 只有 0 满足这一属性 if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) &#123; return false; &#125; int revertedNumber = 0; while (x &gt; revertedNumber) &#123; revertedNumber = revertedNumber * 10 + x % 10; x /= 10; &#125; // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。 // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123， // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。 return x == revertedNumber || x == revertedNumber / 10; &#125;&#125;; 复杂度分析：时间复杂度：O(log n)，对于每次迭代，我们会将输入除以 10，因此时间复杂度为O(logn)。空间复杂度：O(1)。我们只需要常数空间存放若干变量。 法二：数学解法思路：通过取整和取余操作获取整数中对应的数字进行比较。 举个例子：1221 这个数字。 通过计算 1221 / 1000， 得首位1 通过计算 1221 % 10， 可得末位 1 进行比较 再将 22 取出来继续比较 代码:1234567891011121314151617class Solution &#123; public boolean isPalindrome(int x) &#123; //边界判断 if (x &lt; 0) return false; int div = 1; // while (x / div &gt;= 10) div *= 10; while (x &gt; 0) &#123; int left = x / div; int right = x % 10; if (left != right) return false; x = (x % div) / 10; div /= 100; &#125; return true; &#125;&#125; 法三:整数转字符串(看个乐)代码:123456class Solution &#123; public boolean isPalindrome(int x) &#123; String reversedStr = (new StringBuilder(x + \"\")).reverse().toString(); return (x + \"\").equals(reversedStr); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode题解","slug":"算法/Leetcode题解","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://moersuo.github.io/tags/Leetcode%E9%A2%98%E8%A7%A3/"}]},{"title":"剑指offer 05替换空格","slug":"剑指offer-05替换空格","date":"2020-10-02T08:09:27.000Z","updated":"2020-10-04T06:42:23.900Z","comments":true,"path":"2020/10/02/剑指offer-05替换空格/","link":"","permalink":"http://moersuo.github.io/2020/10/02/%E5%89%91%E6%8C%87offer-05%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/","excerpt":"","text":"题目： 请实现一个函数，把字符串 s 中的每个空格替换成”%20”。 示例： 输入：s = “We are happy.”输出：”We%20are%20happy.” 限制： 0 &lt;= s 的长度 &lt;= 10000 官方法一：思路：由于每次替换从 1 个字符变成 3 个字符，使用字符数组可方便地进行替换。建立字符数组地长度为 s 的长度的 3 倍，这样可保证字符数组可以容纳所有替换后的字符。 1.创建字符数组，其长度为length * 3 2.初始化size为0，size表示替换后的字符串的长度 3.从左到右遍历字符串s 利用charAt方法获得s的当前字符c 如果c为空格，则利用size的三次自增使得array[size] = “%”,array[size+1] = “2”,array[size+2] = “0”,且size增加3 如果c不是空格，则另array[size] = c，且size加1 4.遍历结束后，size的值等于替换后字符串的长度，从array的前size个字符创建新字符串，并返回 代码：12345678910111213141516171819class Solution &#123; public String replaceSpace(String s) &#123; int length = s.length(); char[] array = new char[length * 3]; int size = 0; for (int i = 0; i &lt; length; i++) &#123; char c = s.charAt(i); if (c == ' ') &#123; array[size++] = '%'; array[size++] = '2'; array[size++] = '0'; &#125; else &#123; array[size++] = c; &#125; &#125; String newStr = new String(array, 0, size); return newStr; &#125;&#125; 复杂度分析： 时间复杂度：O(n)。遍历字符串 s 一遍。 空间复杂度：O(n)。额外创建字符数组，长度为 s 的长度的 3 倍。 法二：思路：和上面差不多，就是把字符串中的每个字符一个个添加到StringBuilder中，如果遇到空格就把他换成%20。 代码：12345678910public String replaceSpace(String s) &#123; StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; s.length(); i++) &#123; if (s.charAt(i) == ' ') stringBuilder.append(\"%20\"); else stringBuilder.append(s.charAt(i)); &#125; return stringBuilder.toString(); &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"剑指offer","slug":"算法/剑指offer","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://moersuo.github.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"线程的五大状态","slug":"线程的五大状态","date":"2020-09-29T09:26:52.000Z","updated":"2020-10-04T06:41:53.331Z","comments":true,"path":"2020/09/29/线程的五大状态/","link":"","permalink":"http://moersuo.github.io/2020/09/29/%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%94%E5%A4%A7%E7%8A%B6%E6%80%81/","excerpt":"","text":"概述：线程的五大状态为：创建状态，就绪状态，阻塞状态，运行状态，死亡状态 new: Thread t = new Thread() 线程一旦创建，就进入到了创建状态。 就绪状态： 当调用start()方法，线程立即进入就绪状态，但不意味着立即调度执行。 运行状态：进入运行状态，线程才真正执行线程体的代码块。 阻塞状态： 当调用sleep，wait或同步锁定时，线程进入阻塞状态，就是代码不往下执行，阻塞事件解除后，重新进入就绪状态，等待cpu调度执行。 dead：线程中断或结束，一旦进入死亡状态，就不能再次启动。 停止线程：1.不推荐使用JDK提供的stop(),destory()方法 2.最好让线程自己停下来 3.建议使用一个标志位进行终止变量，当flag = false 时，终止线程运行。 样例：123456789101112131415161718192021222324252627282930package multithread.state;public class TestStop implements Runnable&#123; //1.设置1个标识位 private boolean flag = true; @Override public void run()&#123; int i =0; while(flag)&#123; System.out.println(\"run...Thread\"+i++); &#125; &#125; //2.设置一个公开的方法停止线程，转换标识位 public void stop()&#123; this.flag = false; &#125; public static void main(String[] args)&#123; TestStop testStop = new TestStop(); new Thread(testStop).start(); for (int i = 0; i &lt; 1000; i++) &#123; System.out.println(\"lalala\"+i); if(i == 900)&#123; //调用stop方法切换标识为，让线程停止 testStop.stop(); System.out.println(\"线程该停止了\"); &#125; &#125; &#125;&#125; 线程休眠： sleep(时间) 指定当前线程阻塞的毫秒数； sleep存在异常interruptedException; sleep时间达到后线程进入就绪状态 sleep可以模拟网络延时，倒计时等。 每个对象都有一个锁，sleep不会释放锁。 样例1：模拟抢票1234567891011121314151617181920212223242526package multithread.state;// 模拟抢票public class TestSleep implements Runnable&#123; // 票数 private int ticketNums = 10; public void run()&#123; while(true)&#123; if(ticketNums &lt;= 0) &#123; break; &#125; System.out.println(Thread.currentThread().getName()+\"抢到了第\"+ticketNums--+\"张票\"); &#125; // 模拟延时 try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args)&#123; TestSleep ticket = new TestSleep(); new Thread(ticket,\"小明\").start(); new Thread(ticket,\"小王\").start(); new Thread(ticket,\"小张\").start(); &#125;&#125; 样例2：模拟倒计时123456789101112131415161718192021package multithread.state;//模拟倒计时public class TestSleep2 &#123; public static void turndown() throws InterruptedException &#123; int num = 10; while(true)&#123; Thread.sleep(1000); System.out.println(num--); if(num &lt; 0)&#123; break; &#125; &#125; &#125; public static void main(String[] args)&#123; try &#123; turndown(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 线程礼让： 礼让线程，让当前正在执行的线程暂停，但不阻塞。 将线程从运行状态转为就绪状态 让cpu重新调度，礼让不一定成功，看cpu心情。 样例： 1234567891011121314151617package multithread.state;public class TestYield&#123; public static void main(String[] args )&#123; MyYield testYield= new MyYield(); new Thread(testYield,\"1\").start(); new Thread(testYield,\"2\").start(); &#125;&#125;class MyYield implements Runnable&#123; @Override public void run()&#123; System.out.println(Thread.currentThread().getName()+\"开始运行\"); Thread.yield(); System.out.println(Thread.currentThread().getName()+\"停止运行\"); &#125;&#125; 线程强制执行： 某一个线程对象可以一直独占资源，其他线程阻塞，一直到该线程的程序执行结束。 可以想象成插队 123456789101112131415161718192021package multithread.state;public class TestJoin implements Runnable&#123; @Override public void run()&#123; for(int i = 0; i &lt; 1000; i++)&#123; System.out.println(\"我是\"+i); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; TestJoin testJoin = new TestJoin(); Thread thread = new Thread(testJoin); thread.start(); for(int i = 0; i &lt; 1000; i++)&#123; if(i == 200)&#123; thread.join(); &#125; System.out.println(\"你是\"+i); &#125; &#125;&#125; 观察线程状态：12345678910111213141516171819202122232425262728293031323334package multithread.state;import javax.swing.*;//观察线程状态public class TestState &#123; public static void main(String[] args) throws InterruptedException &#123; Thread thread = new Thread(()-&gt;&#123; for(int i = 0; i &lt; 5; i++)&#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(\"lalala\"); &#125;); //观察状态 Thread.State state = thread.getState(); System.out.println(state); // NEW //观察启动后 thread.start(); state = thread.getState(); System.out.println(state); //RUN while(state != Thread.State.TERMINATED)&#123;//只要线程不停止，就一直输出状态 Thread.sleep(100); state = thread.getState();//更新线程状态 System.out.println(state);//输出状态 &#125; &#125;&#125; ​","categories":[{"name":"后端学习","slug":"后端学习","permalink":"http://moersuo.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"},{"name":"多线程","slug":"后端学习/多线程","permalink":"http://moersuo.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://moersuo.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"剑指offer 04二维数组中的查找","slug":"剑指offer-04二维数组中的查找","date":"2020-09-29T08:26:50.000Z","updated":"2020-10-04T06:42:12.115Z","comments":true,"path":"2020/09/29/剑指offer-04二维数组中的查找/","link":"","permalink":"http://moersuo.github.io/2020/09/29/%E5%89%91%E6%8C%87offer-04%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/","excerpt":"","text":"题目： 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例：现有矩阵matrix如下 [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 限制： 0 &lt;= n &lt;= 1000 0 &lt;= m &lt;= 1000 官方法一：暴力思路：在不考虑二维数组已经排好序的情况下，直接遍历整个二维数组的每一个元素，判断目标值是否在二维数组中存在。 注：二维数组的行列长度可用 int rows = matrix.length, columns = matrix[0].length; 表示 代码：12345678910111213141516class Solution &#123; public boolean findNumberIn2DArray(int[][] matrix, int target) &#123; if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123; return false; &#125; int rows = matrix.length, columns = matrix[0].length; for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; columns; j++) &#123; if (matrix[i][j] == target) &#123; return true; &#125; &#125; &#125; return false; &#125;&#125; 复杂度分析： 时间复杂度：O(nm)。二维数组中的每个元素都被遍历，因此时间复杂度为二维数组的大小。 空间复杂度：O(n)。 官方法二：线性查找思路：由于给的的数组为有序的，因此每当访问到一个元素时便可排除部分元素。 从二维数组的右上角开始查找。如果当前元素等于目标值，则返回 true。如果当前元素大于目标值，则移到左边一列。如果当前元素小于目标值，则移到下边一行。 1.若数组为空，返回false 2.初始化行下标为0，列下标为二维数组的列数-1 3.重复以下步骤，直到行下标或列下标超出边界 获得当前下标位置的元素 num如果 num 和 target 相等，返回 true如果 num 大于 target，列下标减 1如果 num 小于 target，行下标加 1 4.循环执行完毕后仍未找到元素等于目标值，则说明不存在这样的元素，返回false。 1234567891011121314151617181920class Solution &#123; public boolean findNumberIn2DArray(int[][] matrix, int target) &#123; if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123; return false; &#125; int rows = matrix.length, columns = matrix[0].length; int row = 0, column = columns - 1; while (row &lt; rows &amp;&amp; column &gt;= 0) &#123; int num = matrix[row][column]; if (num == target) &#123; return true; &#125; else if (num &gt; target) &#123; column--; &#125; else &#123; row++; &#125; &#125; return false; &#125;&#125; 复杂度分析：时间复杂度：O(n+m)。访问到的下标的行最多增加 n 次，列最多减少 m 次，因此循环体最多执行 n + m 次。空间复杂度：O(1)。","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"剑指offer","slug":"算法/剑指offer","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://moersuo.github.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"剑指offer 03数组中重复的数字","slug":"剑指offer-03数组中重复的数字","date":"2020-09-28T12:06:24.000Z","updated":"2020-10-04T06:40:22.930Z","comments":true,"path":"2020/09/28/剑指offer-03数组中重复的数字/","link":"","permalink":"http://moersuo.github.io/2020/09/28/%E5%89%91%E6%8C%87offer-03%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/","excerpt":"","text":"题目： 找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字 示例： 123输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 限制： 2 &lt;= n &lt;= 100000 java：法一 使用集合set思路：由于只需要找出数组中任意一个重复的数字，因此遍历数组，遇到重复的数字即返回。为了判断一个数字是否重复遇到，使用集合存储已经遇到的数字，如果遇到的一个数字已经在集合中，则当前的数字是重复数字。 1.初始化集合为空集合，重复的数字 pepeat = -1 2.遍历数组中的每个元素，尝试将每个元素添加入集合中。若添加失败，则证明该元素已在集合中，将元素的值赋给repeat，结束循环。 3.返回repeat 代码：12345678910111213class Solution &#123; public int findRepeatNumber(int[] nums) &#123; Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); int repeat = -1; for (int num : nums) &#123; if (!set.add(num)) &#123; repeat = num; break; &#125; &#125; return repeat; &#125;&#125; 复杂度分析： 时间复杂度：O(n)：遍历数组一遍。使用哈希集合（HashSet），添加元素的时间复杂度为 O(1)，故总的时间复杂度是 O(n)。 空间复杂度：O(n)。不重复的每个元素都可能存入集合，因此占用 O(n) 额外空间。 法二：使用临时数组思路：我们可以申请一个临时数组temp，因为nums元素中的每个元素的大小都在0~n-1之间，所以我们可以把nums中元素的值和临时数组temp建立映射关系，就是nums中元素的值是几，我们就把temp中对应的位置值加1，当temp某个位置的值大于1的时候，就表示出现了重复，我们直接返回即可 12345678910public int findRepeatNumber(int[] nums) &#123; int length = nums.length; int[] temp = new int[length]; for (int i = 0; i &lt; length; i++) &#123; temp[nums[i]]++; if (temp[nums[i]] &gt; 1) return nums[i]; &#125; return -1; &#125; 法三：原地置换思路：如果没有重复数字，那么正常排序后，数字i应该在下标为i的位置，所以思路是重头扫描数组，遇到下标为i的数字如果不是i的话，（假设为m),那么我们就拿与下标m的数字交换。在交换过程中，如果有重复的数字发生，那么终止返回ture 12345678910111213141516class Solution &#123; public int findRepeatNumber(int[] nums) &#123; int temp; for(int i=0;i&lt;nums.length;i++)&#123; while (nums[i]!=i)&#123; if(nums[i]==nums[nums[i]])&#123; return nums[i]; &#125; temp=nums[i]; nums[i]=nums[temp]; nums[temp]=temp; &#125; &#125; return -1; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"剑指offer","slug":"算法/剑指offer","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://moersuo.github.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"剑指offer 22链表中倒数第k个节点","slug":"剑指offer-22链表中倒数第k个节点","date":"2020-09-27T13:58:22.000Z","updated":"2020-10-04T06:42:31.234Z","comments":true,"path":"2020/09/27/剑指offer-22链表中倒数第k个节点/","link":"","permalink":"http://moersuo.github.io/2020/09/27/%E5%89%91%E6%8C%87offer-22%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/","excerpt":"","text":"题目： 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。 实例： 123给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.返回链表 4-&gt;5. java：双指针解题思路： 利用双指针我们可以不考虑链表总长度，快指针先走k步，再让双指针同时前进，当快指针指向null时，慢指针剩下的部分即为所求值 1.初始化：建立快慢指针，均指向头结点 2.快指针向前走k步，慢指针不动 3.构建循环，双指针同时向前移动，当快指针为null跳出时，慢指针与尾结点距离为k-1，是倒数第k个节点。 4.返回慢指针 注意考虑边界问题 1）head为空指针 2）输入参数k为0 3）k大于链表长度 12345678910111213141516171819class Sloution&#123; public ListNode getKthFromEnd(ListNode head, int k) &#123; //边界问题：head为空指针，输入的参数k为0 if(head == null || k == 0) return null; ListNode fast = head,slow = head; for(int i = 0; i&lt; k ; i++)&#123; if(fast == null &amp;&amp; i &lt; k)&#123; // 边界问题：k大于链表长度 return null; &#125; fast = fast.next; &#125; while(fast!=null)&#123; fast = fast.next; slow = slow.next; &#125; return slow; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"剑指offer","slug":"算法/剑指offer","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://moersuo.github.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"三种方式实现多线程","slug":"三种方式实现多线程","date":"2020-09-27T06:19:28.000Z","updated":"2020-09-27T06:20:11.109Z","comments":true,"path":"2020/09/27/三种方式实现多线程/","link":"","permalink":"http://moersuo.github.io/2020/09/27/%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"java实现多线程的三种方式继承Thread类，实现Runnable接口，实现callable接口 *继承Thread类子类继承Thead类具备多线程能力 启动线程：子类对象.start() 不建议使用：避免OOP单继承局限性 12345678910111213141516public class Thread1 extends Thread&#123; @Override // 使用继承thread方法创建多线程 public void run()&#123; for(int i = 0; i &lt; 20; i++)&#123; System.out.println(\"我在执行分支任务\"+i); &#125; &#125; public static void main(String[] args)&#123; Thread1 thread1 = new Thread1(); thread1.start(); for(int i = 0; i &lt; 20; i++)&#123; System.out.println(\"我在执行主线任务\"+i); &#125; &#125;&#125; *实现Runnable接口实现接口Runnable具有多线程能力 启动线程：传入目标对象+Thread对象.start() 推荐使用，避免单继承局限性，灵活方便，方便同一个对象被多个线程使用 123456789101112131415161718public class Runnable1 implements Runnable&#123; @Override // 使用实现Runnable方法创建多线程 public void run()&#123; for(int i = 0; i &lt; 20; i++)&#123; System.out.println(\"我在执行分支任务\"+i); &#125; &#125; public static void main(String[] args)&#123; Runnable1 Runnable1 = new Runnable1(); //Thread thread = new Thread(Runnable1); //thread.start(); new Thread(Runnable1).start(); for(int i = 0; i &lt; 20; i++)&#123; System.out.println(\"我在执行主线任务\"+i); &#125; &#125;&#125; *实现Callable接口1.实现callable接口需要返回值类型 2.重写call方法，需要抛出异常 3.创建目标对象 4.创建执行服务：ExecutorService ser =Executors.newFixedThreadPool(1); 5.提交执行：Futureresult1=ser.submit(t1); 6.获取结果：bollean r1 = result1.get() 7.关闭服务：ser.shutdownNow(); 1234567891011121314151617181920212223242526272829package course.multithread.callable;import java.util.concurrent.*;public class CallableTest implements Callable&lt;Boolean&gt; &#123; @Override // 使用实现callable方法创建多线程 public Boolean call()&#123; for(int i = 0; i &lt; 20; i++)&#123; System.out.println(\"我在执行分支任务\"+i); &#125; return true; &#125; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; CallableTest t1= new CallableTest(); //创建执行服务： ExecutorService ser = Executors.newFixedThreadPool(1); //提交执行： Future&lt;Boolean&gt; r1 = ser.submit(t1); //获取结果： boolean rs1 = r1.get(); System.out.println(rs1); //关闭服务： ser.shutdownNow(); for(int i = 0; i &lt; 20; i++)&#123; System.out.println(\"我在执行主线任务\"+i); &#125; &#125;&#125;","categories":[{"name":"后端学习","slug":"后端学习","permalink":"http://moersuo.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"},{"name":"多线程","slug":"后端学习/多线程","permalink":"http://moersuo.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://moersuo.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Linux下JDK安装问题","slug":"Linux下JDK安装问题","date":"2020-08-17T01:25:27.000Z","updated":"2020-08-17T01:26:35.235Z","comments":true,"path":"2020/08/17/Linux下JDK安装问题/","link":"","permalink":"http://moersuo.github.io/2020/08/17/Linux%E4%B8%8BJDK%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/","excerpt":"","text":"新的linux环境下配置JDK环境出现-bash: /usr/local/jdk1.8/jdk1.8.0_181/bin/java: /lib/ld-linux.so.2: bad ELF interpreter: No such file or directory解决方法： 安装glibc.i686库 yum install glibc.i686 glibc是GNU发布的libc库，即c运行库。glibc是linux系统中最底层的api，几乎其它任何运行库都会依赖于glibc。glibc除了封装linux操作系统所提供的系统服务外，它本身也提供了许多其它一些必要功能服务的实现。由于 glibc 囊括了几乎所有的 UNIX 通行的标准，可以想见其内容包罗万象。 发行版中的i386/i686/x86-64的区别：baii386用来du处理32位系统，i686是i386的下集；x86-64用来处理64位系统。linux发行zhi版中的i386/i686/x86-64各自含义： 1、i386通常被用来作为对daoIntel（英特尔）32位微处理器的统称； 2、i386的子集包含i686，i686适用于Pentium Pro，也适用于K7架构的Athlon； 3、x86-64，又称“AMD64”或“x64”，是一种64位元的电脑处理器架构。它是建基于现有32位元的x86架构，由AMD公司所开发。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://moersuo.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"Linux","slug":"计算机基础/Linux","permalink":"http://moersuo.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://moersuo.github.io/tags/Linux/"}]},{"title":"Leetcode题解026：删除排序数组中的重复项","slug":"Leetcode题解026：删除排序数组中的重复项","date":"2020-06-23T11:35:11.000Z","updated":"2020-06-23T11:36:01.891Z","comments":true,"path":"2020/06/23/Leetcode题解026：删除排序数组中的重复项/","link":"","permalink":"http://moersuo.github.io/2020/06/23/Leetcode%E9%A2%98%E8%A7%A3026%EF%BC%9A%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/","excerpt":"","text":"删除排序数组中的重复项题目： 给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成 示例1： 给定数组 nums = [1,1,2],&emsp;函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。&emsp;你不需要考虑数组中超出新长度后面的元素。 示例2： 给定 nums = [0,0,1,1,1,2,2,3,3,4],&emsp;函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。&emsp;你不需要考虑数组中超出新长度后面的元素。 说明：为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);&emsp;// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) {print(nums[i]);}’ 官方题解：双指针思路：数组完成排序后，我们可以放置两个指针 i和 j，其中 i 是慢指针，而 j 是快指针。只要 nums[i] = nums[j]，我们就增加 j 以跳过重复项。 当我们遇到 nums[j] ≠ nums[i] 时，跳过重复项的运行已经结束，因此我们必须把它（nums[j]）的值复制到 nums[i + 1]。然后递增 i，接着我们将再次重复相同的过程，直到 j 到达数组的末尾为止。 1234567891011public int removeDuplicates(int[] nums) &#123; if (nums.length == 0) return 0; int i = 0; for (int j = 1; j &lt; nums.length; j++) &#123; if (nums[j] != nums[i]) &#123; i++; nums[i] = nums[j]; &#125; &#125; return i + 1;&#125; 时间复杂度：O(n)，假设数组的长度是 n，那么 i 和 j分别最多遍历 n 步。空间复杂度：O(1) 优化：考虑如下数组【0,1,2,3,4,5】。此时数组中没有重复元素，按照上面的说法，每次比较时 nums[j] 都不等于 nums[i]，因此就会将 j指向的元素原地复制一遍，这个操作其实是不必要的。 因此我们可以添加一个小判断，当 j- i &gt; 1 时，才进行复制。 1234567891011121314class Solution &#123; public int removeDuplicates(int[] nums) &#123; int i = 0; for(int j = 1; j &lt;nums.length; j++)&#123; if(nums[i] != nums[j])&#123; if(j-i &gt; 1)&#123; nums[i+1] = nums[j]; &#125; i++; &#125; &#125; return i+1; &#125;&#125; 时间复杂度：O(n)空间复杂度：O(1) JS：123456789101112var removeDuplicates = function(nums) &#123; const size = nums.length; if(size==0) return 0; let slowP = 0; for (let fastP = 0; fastP &lt; size; fastP++) &#123; if (nums[fastP] !== nums[slowP]) &#123; slowP++; nums[slowP] = nums[fastP] &#125; &#125; return slowP + 1;&#125;; 变形：Leetcode027 移除元素给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 官方题解1：双指针思路：当 nums[j] 与给定的值相等时，递增 j 以跳过该元素。只要 nums[j]不等于val，我们就复制 nums[j]到 nums[i]并同时递增两个索引。重复这一过程，直到 j 到达数组的末尾，该数组的新长度为 i。 12345678910public int removeElement(int[] nums, int val) &#123; int i = 0; for (int j = 0; j &lt; nums.length; j++) &#123; if (nums[j] != val) &#123; nums[i] = nums[j]; i++; &#125; &#125; return i;&#125; 时间复杂度：O(n)，假设数组总共有 n 个元素，i 和 j 至少遍历 2n 步。空间复杂度：O(1) 官方题解2：双指针–当要删除的元素很少时思路：现在考虑数组包含很少的要删除的元素的情况。例如，num=[1，2，3，5，4]，Val=4。之前的算法会对前四个元素做不必要的复制操作。另一个例子是 num=[4，1，2，3，5]，Val=4。似乎没有必要将 [1，2，3，5]这几个元素左移一步，因为问题描述中提到元素的顺序可以更改。 当我们遇到 nums[i] = val 时，我们可以将当前元素与最后一个元素进行交换，并释放最后一个元素。这实际上使数组的大小减少了 1。 请注意，被交换的最后一个元素可能是您想要移除的值。但是不要担心，在下一次迭代中，我们仍然会检查这个元素。 1234567891011121314public int removeElement(int[] nums, int val) &#123; int i = 0; int n = nums.length; while (i &lt; n) &#123; if (nums[i] == val) &#123; nums[i] = nums[n - 1]; // reduce array size by one n--; &#125; else &#123; i++; &#125; &#125; return n;&#125; 时间复杂度：O(n)，i 和 n 最多遍历 n 步。在这个方法中，赋值操作的次数等于要删除的元素的数量。因此，如果要移除的元素很少，效率会更高。空间复杂度：O(1)。","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode题解","slug":"算法/Leetcode题解","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://moersuo.github.io/tags/Leetcode%E9%A2%98%E8%A7%A3/"}]},{"title":"Leetcode题解021：合并两个有序的链表","slug":"Leetcode题解021：合并两个有序的链表","date":"2020-06-22T14:39:16.000Z","updated":"2020-06-22T14:40:54.804Z","comments":true,"path":"2020/06/22/Leetcode题解021：合并两个有序的链表/","link":"","permalink":"http://moersuo.github.io/2020/06/22/Leetcode%E9%A2%98%E8%A7%A3021%EF%BC%9A%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/","excerpt":"","text":"合并两个有序的链表题目： 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 官方解法1：递归想法：我们可以如下递归地定义在两个链表里的 merge 操作（忽略边界情况，比如空链表等）: list1[0]+merge(list1[1:],list2) &emsp;list1[0]&lt;list2[0]list2[0]+merge(list1,list2[1:]) &emsp;otherwise 算法：如果 l1 或者 l2 一开始就是 null ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个的头元素更小，然后递归地决定下一个添加到结果里的值。如果两个链表都是空的，那么过程终止，所以递归过程最终一定会终止。终止条件：两条链表分别名为 l1 和 l2，当 l1 为空或 l2 为空时结束返回值：每一层调用都返回排序好的链表头 12345678910111213141516171819class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) &#123; return l2; &#125; else if (l2 == null) &#123; return l1; &#125; else if (l1.val &lt; l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125; &#125;&#125; 时间复杂度：O(n+m)。 因为每次调用递归都会去掉 l1 或者 l2 的头元素（直到至少有一个链表为空），函数 mergeTwoList 中只会遍历每个元素一次。所以，时间复杂度与合并后的链表长度为线性关系。 空间复杂度：O(n+m)。调用 mergeTwoLists 退出时 l1 和 l2 中每个元素都一定已经被遍历过了，所以 n + mn+m 个栈帧会消耗 O(n + m)O(n+m) 的空间 官方解法2：迭代想法：我们可以用迭代的方法来实现上述算法。我们假设 l1 元素严格比 l2元素少，我们可以将 l2 中的元素逐一插入 l1 中正确的位置。算法：首先，我们设定一个哨兵节点 “prehead” ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 prev 指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：如果 l1 当前位置的值小于等于 l2 ，我们就把 l1 的值接在 prev 节点的后面同时将 l1 指针往后移一个。否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都把 prev 向后移一个元素。 在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表。 12345678910111213141516171819202122class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode prehead = new ListNode(-1); ListNode prev = prehead; // 保持对返回节点前面的节点的引用不变。 while (l1 != null &amp;&amp; l2 != null) &#123; if (l1.val &lt;= l2.val) &#123; prev.next = l1; l1 = l1.next; &#125; else &#123; prev.next = l2; l2 = l2.next; &#125; prev = prev.next; &#125; //l1，l2此时恰有一个非空，将其合并到合并列表的末尾 prev.next = l1 == null ? l2 : l1; //l1为空则pre.next = l2，反之亦然 return prehead.next; &#125;&#125; JS：123456789101112131415const mergeTwoLists = function (l1, l2) &#123; if (l1 === null) &#123; return l2; &#125; if (l2 === null) &#123; return l1; &#125; if (l1.val &lt; l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode题解","slug":"算法/Leetcode题解","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://moersuo.github.io/tags/Leetcode%E9%A2%98%E8%A7%A3/"}]},{"title":"Leetcode题解020：有效的括号","slug":"Leetcode题解020：有效的括号","date":"2020-06-19T12:50:04.000Z","updated":"2020-06-22T14:40:23.587Z","comments":true,"path":"2020/06/19/Leetcode题解020：有效的括号/","link":"","permalink":"http://moersuo.github.io/2020/06/19/Leetcode%E9%A2%98%E8%A7%A3020%EF%BC%9A%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/","excerpt":"","text":"有效的括号题目： 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。有效字符串需满足：1.左括号必须用相同类型的右括号闭合。2.左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 示例： 输入: “()”输出: true 输入: “()[]{}”输出: true 输入: “(]”输出: false 输入: “([)]”输出: false 输入: “{[]}”输出: true Java：官方题解：1.建立哈希表。2.初始化栈 S，一次处理表达式的每个括号。3.如果遇到开括号，我们只需将其推到栈上即可。这意味着我们将稍后处理它。4.如果我们遇到一个闭括号，那么我们检查栈顶的元素。如果栈顶的元素是一个相同类型的左括号，那么我们将它从栈中弹出并继续处理。否则，这意味着表达式无效。5.如果到最后我们剩下的栈中仍然有元素，那么这意味着表达式无效。 时间复杂度： O(n)，因为我们一次只遍历给定的字符串中的一个字符并在栈上进行 O(1) 的推入和弹出操作。空间复杂度： O(n)，当我们将所有的开括号都推到栈上时以及在最糟糕的情况下，我们最终要把所有括号推到栈上。例如 ((((((((((。 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; // 负责映射的哈希表。 private HashMap&lt;Character, Character&gt; mappings; // 使用映射初始化哈希映射。这只是使代码更易于阅读。 public Solution() &#123; this.mappings = new HashMap&lt;Character, Character&gt;(); this.mappings.put(')', '('); // this区分成员变量与局部变量 this.mappings.put('&#125;', '&#123;'); this.mappings.put(']', '['); &#125; public boolean isValid(String s) &#123; // 初始化堆栈 Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); // 如果当前字符是右括号 if (this.mappings.containsKey(c)) &#123; // 获取堆栈的顶部元素。如果堆栈是空的，设置一个虚拟值’ # ’ char topElement = stack.empty() ? '#' : stack.pop(); // 如果这个括号的映射与堆栈的顶部元素不匹配，则返回 false。 if (topElement != this.mappings.get(c)) &#123; return false; &#125; &#125; else &#123; // 如果它是一个左括号，则推入堆栈。 stack.push(c); &#125; &#125; // 如果堆栈仍然包含元素，则它是无效的表达式。 return stack.isEmpty(); &#125;&#125; 法二：不使用map遍历祖符串数组中的每个字符c，将每个左括号对应的括号堆入栈中，直到为右括号时，弹出栈元素中储存的右括号元素，比较二者是否相等。 123456789101112131415161718192021class Solution &#123; public boolean isValid(String s) &#123; if(s.isEmpty()) return true; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for(char c:s.toCharArray())&#123; if(c=='(') stack.push(')'); else if(c=='&#123;') stack.push('&#125;'); else if(c=='[') stack.push(']'); else if(stack.empty()||c!=stack.pop()) /* 当不为左括号时候，说明c是右括号， stack.pop弹出栈元素中存储的右括号元素，比较这两个右括号是否相等。*/ return false; &#125; if(stack.empty()) return true; return stack.isEmpty(); &#125;&#125; JS： 12345678910111213141516171819202122232425var isValid = function(s) &#123; let valid = true; const stack = []; const mapper = &#123; '&#123;': \"&#125;\", \"[\": \"]\", \"(\": \")\" &#125; for(let i in s) &#123; const v = s[i]; if (['(', '[', '&#123;'].indexOf(v) &gt; -1) &#123; stack.push(v); &#125; else &#123; const peak = stack.pop(); if (v !== mapper[peak]) &#123; return false; &#125; &#125; &#125; if (stack.length &gt; 0) return false; return valid;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode题解","slug":"算法/Leetcode题解","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://moersuo.github.io/tags/Leetcode%E9%A2%98%E8%A7%A3/"}]},{"title":"Leetcode题解01: 两数之和","slug":"Leetcode题解01-两数之和","date":"2020-06-18T15:50:04.000Z","updated":"2020-06-19T16:41:17.940Z","comments":true,"path":"2020/06/18/Leetcode题解01-两数之和/","link":"","permalink":"http://moersuo.github.io/2020/06/18/Leetcode%E9%A2%98%E8%A7%A301-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"两数之和 题目：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例： 给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] JAVA：官方题解方法一： 暴力法遍历每个元素x，并查找是否存在一个值与 target −x 相等的目标元素。 ·时间复杂度： O(n^2)对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n) 的时间。因此时间复杂度为 O(n^2)·空间复杂度：o（1） 12345678910111213class Solution &#123; public int[] twoSum(int[] nums, int target)&#123; //返回值;方法名;参数 for(int i = 0; i&lt;nums.length; i++)&#123; for(int j = i + 1; j &lt; nums.length; j++)&#123; if(nums[j] == target - nums[i])&#123; return new int[] &#123; i,j &#125;; &#125; &#125; &#125; throw new IllegalArgumentException(\"No two sum solution\"); //不合法的参数 &#125;&#125; 官方方法二：两遍哈希表为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。 通过以空间换取速度的方式，我们可以将查找时间从 O(n)O(n) 降低到 O(1)O(1)。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)O(1)。 一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i] 本身！·时间复杂度：O(n)，我们把包含有 n 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1) ，所以时间复杂度为 O(n)。 ·空间复杂度：O(n)，所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 n 个元素。 123456789101112131415class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; map.put(nums[i], i); &#125; for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123; return new int[] &#123; i, map.get(complement) &#125;; &#125; &#125; throw new IllegalArgumentException(\"No two sum solution\"); &#125;&#125; 官方题解方法三： 一遍哈希表事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。 12345678910111213class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement)) &#123; // 用于判断Map键中是否包含某个键 return new int[] &#123; map.get(complement), i &#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException(\"No two sum solution\"); &#125;&#125; ·时间复杂度：O(n)，我们只遍历了包含有 n 个元素的列表一次。在表中进行的每次查找只花费 O(1)的时间。 ·空间复杂度：O(n)，所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n个元素。 JS：哈希表12345678910const twoSum = function (nums, target) &#123; const map = new Map(); for (let i = 0; i &lt; nums.length; i++) &#123; const diff = target - nums[i]; if (map.has(diff)) &#123; return [map.get(diff), i]; &#125; map.set(nums[i], i); &#125;&#125; 变种：假设数组为有序排列给出left，right左右两指针。初始值分为左右两端。当两者和小于目标值时，左指针向右移一位，当两者和大于目标值时，右指针向左移一位。time: o(n), spece: o(1)； 12345678910111213141516public int[] twoSum(int[] nums, int target) &#123; if (nums == null || nums.length &lt;= 1) return new int[2]; int left = 0; int right = nums.length - 1; while (left &lt; right) &#123; int sum = nums[left] + nums[right]; if (sum &lt; target) &#123; left++; &#125; else if (sum &gt; target) &#123; right--; &#125; else &#123; return new int[] &#123;left, right&#125;; &#125; &#125; return new int[2]; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode题解","slug":"算法/Leetcode题解","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://moersuo.github.io/tags/Leetcode%E9%A2%98%E8%A7%A3/"}]}],"categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"剑指offer","slug":"算法/剑指offer","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"},{"name":"Leetcode题解","slug":"算法/Leetcode题解","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3/"},{"name":"后端学习","slug":"后端学习","permalink":"http://moersuo.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"},{"name":"JavaWeb","slug":"后端学习/JavaWeb","permalink":"http://moersuo.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/JavaWeb/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://moersuo.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"编程语言","slug":"计算机基础/编程语言","permalink":"http://moersuo.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"数据库","slug":"后端学习/数据库","permalink":"http://moersuo.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"多线程","slug":"后端学习/多线程","permalink":"http://moersuo.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"Linux","slug":"计算机基础/Linux","permalink":"http://moersuo.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Linux/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://moersuo.github.io/tags/%E5%89%91%E6%8C%87offer/"},{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://moersuo.github.io/tags/Leetcode%E9%A2%98%E8%A7%A3/"},{"name":"jQuery","slug":"jQuery","permalink":"http://moersuo.github.io/tags/jQuery/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://moersuo.github.io/tags/JavaWeb/"},{"name":"Java","slug":"Java","permalink":"http://moersuo.github.io/tags/Java/"},{"name":"MySQL","slug":"MySQL","permalink":"http://moersuo.github.io/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"http://moersuo.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"多线程","slug":"多线程","permalink":"http://moersuo.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"Linux","slug":"Linux","permalink":"http://moersuo.github.io/tags/Linux/"}]}