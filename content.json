{"meta":{"title":"Morsol","subtitle":"","description":"","author":"morsol","url":"http://moersuo.github.io","root":"/moersuo.github.io/"},"pages":[],"posts":[{"title":"剑指offer09：用两个栈实现队列","slug":"剑指offer09：用两个栈实现队列","date":"2020-10-16T02:02:37.000Z","updated":"2020-10-16T04:48:37.441Z","comments":true,"path":"2020/10/16/剑指offer09：用两个栈实现队列/","link":"","permalink":"http://moersuo.github.io/2020/10/16/%E5%89%91%E6%8C%87offer09%EF%BC%9A%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/","excerpt":"","text":"题目： 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 示例： 输入：[“CQueue”,”appendTail”,”deleteHead”,”deleteHead”][[],[3],[],[]]输出：[null,null,3,-1] 输入：[“CQueue”,”deleteHead”,”appendTail”,”appendTail”,”deleteHead”,”deleteHead”][[],[],[5],[2],[],[]]输出：[null,-1,null,null,5,2] 提示： 1 &lt;= values &lt;= 10000最多会对 appendTail、deleteHead 进行 10000 次调用 法一：使用双Stack模拟插入和删除操作思路: 根据题意，首先想到的便是用两个栈分别模拟在队列尾部插入整数和队列头部删除整数 因为栈是先进后出，而队列是先进先出。所以我们可以使用将插入栈压入删除栈的办法来模拟，队列的添加删除 在appendTail方法中，正常将元素压入栈1 在deleteHead方法中，判断删除栈是否为空 为空，循环将插入栈的元素压入删除栈中，直到插入栈为空时停止 当删除栈不为空时，返回一个弹出的栈顶元素；或删除栈为空，但插入栈也为空，没有元素可插入，此时返回 -1. 代码：123456789101112131415161718192021222324252627class CQueue &#123; public Stack&lt;Integer&gt; stack1; public Stack&lt;Integer&gt; stack2; public CQueue() &#123; stack1 = new Stack&lt;&gt;(); // 插入栈 stack2 = new Stack&lt;&gt;(); //删除栈 &#125; public void appendTail(int value) &#123; stack1.push(value); &#125; public int deleteHead() &#123; if(stack2.isEmpty())&#123; while(!stack1.isEmpty())&#123; stack2.push(stack1.pop()); &#125; &#125; return stack2.isEmpty() ? -1 : stack2.pop(); &#125;&#125;/** * Your CQueue object will be instantiated and called as such: * CQueue obj = new CQueue(); * obj.appendTail(value); * int param_2 = obj.deleteHead(); */ 法二：使用LinkedList模拟双栈操作思路： 与双栈基本类似，区别在deleteHead思路不同 当删除栈不为空时，返回弹出的栈顶元素 当插入栈为空时，返回 -1 当插入栈不为空时，将插入栈压入删除栈，直到插入栈为空时截止 返回删除栈弹出的栈顶元素 代码：12345678910111213141516class CQueue &#123; LinkedList&lt;Integer&gt; l1, l2; public CQueue() &#123; l1 = new LinkedList&lt;Integer&gt;(); l2 = new LinkedList&lt;Integer&gt;(); &#125; public void appendTail(int value) &#123; l1.addLast(value); &#125; public int deleteHead() &#123; if(!l2.isEmpty()) return l2.removeLast(); if(l1.isEmpty()) return -1; while(!l1.isEmpty()) l2.addLast(l1.removeLast()); return l2.removeLast(); &#125; 两者复杂度分析： 时间复杂度：O(1)，插入为O(1)操作，删除 只需要完成n个元素的倒序，均摊下来为O(1) 空间复杂度：O(N)","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"剑指offer","slug":"算法/剑指offer","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://moersuo.github.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"MySQL版本相关问题","slug":"MySQL版本相关问题","date":"2020-10-14T01:04:03.000Z","updated":"2020-10-14T01:15:52.011Z","comments":true,"path":"2020/10/14/MySQL版本相关问题/","link":"","permalink":"http://moersuo.github.io/2020/10/14/MySQL%E7%89%88%E6%9C%AC%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/","excerpt":"","text":"一.com.mysql.cj.jdbc.Driver与com.mysql.jdbc.Driver区别:com.mysql.cj.jdbc.Driver是mysql-connector-java 6 中的特性，相比mysql-connector-java 5 多了一个时区：serverTimezone 报错方式: Loading class com.mysql.jdbc.Driver&#39;. This is deprecated. The new driver class iscom.mysql.cj.jdbc.Driver’. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.Exception in thread “main” java.sql.SQLException: The server time zone value ‘�й���׼ʱ��’ is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the ‘serverTimezone’ configuration property) to use a more specifc time zone value if you want to utilize time zone support. 解决方法： 将com.mysql.jdbc.driver替换为com.mysql.cj.jdbc.driver 在url配置中加入serverTimezone=GMT%2B8，如果前面有其他配置使用&amp;连接","categories":[{"name":"后端学习","slug":"后端学习","permalink":"http://moersuo.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"},{"name":"数据库","slug":"后端学习/数据库","permalink":"http://moersuo.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://moersuo.github.io/tags/MySQL/"}]},{"title":"JDBC","slug":"JDBC","date":"2020-10-13T08:34:34.000Z","updated":"2020-10-15T14:17:51.004Z","comments":true,"path":"2020/10/13/JDBC/","link":"","permalink":"http://moersuo.github.io/2020/10/13/JDBC/","excerpt":"","text":"一.概述1.什么是JDBCJDBC(Java Database Connectivity)是一个独立于特定数据库管理系统（DBMS）、通用的SQL数据库存取和操作的公共接口（一组API），定义了用来访问数据库的标准Java类库，使用这个类库可以以一种标准的方法、方便地访问数据库资源 JDBC为访问不同的数据库提供了一种统一的途径，为开发者屏蔽了一些细节问题。 2.组成 面向应用的API：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。 面向数据库的API：Java Driver API，供开发商开发数据库驱动程序用。 3.JDBC编写步骤 加载与注册驱动 URl 获取连接 执行增删改查 释放资源 二.初识JDBC案例1.1使用statement的增删改12345678910111213141516171819202122232425262728293031323334package mysql;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;public class TestConnection1 &#123; public static void main(String[] args) throws SQLException, ClassNotFoundException &#123; //DriverManager.registerDriver(new Driver()); 注册驱动，不推荐使用 //1.加载驱动 Class.forName(\"com.mysql.cj.jdbc.Driver\"); //2.获取连接 Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost/数据库名?serverTimezone=GMT%2B8\",\"账户名\",\"密码\"); System.out.println(\"连接成功\"); //3.执行增删改查 //3.1编写sql语句 //删除 // String sql = \"delete from beauty where id = 9\"; //更新 // String sql = \"update beauty set name = 'lalala' where id = 7\"; //增加 String sql = \"insert into beauty values(null,'lalala','女','1999-1-1','110',null,'3')\"; //3.2 获取执行sql语句的命令对象 Statement statement = connection.createStatement(); //3.3使用sql对象执行sql语句 int update = statement.executeUpdate(sql); //3.4处理执行结果 System.out.println(update&gt;0?\"success\":\"failure\"); //4.关闭连接 statement.close(); connection.close(); &#125;&#125; 案例1.2使用statement的查询123456789101112131415161718192021222324252627282930313233343536package mysql;import java.sql.*;public class TestConnection2&#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; //1.加载驱动 Class.forName(\"com.mysql.cj.jdbc.Driver\"); //固定写法 //2.用户信息和url String url = \"jdbc:mysql://localhost:3306/数据库名?useUnicode=true&amp;characterEncoding=utf8&amp;useSSl=true&amp;serverTimezone=GMT%2B8\"; String username = \"账户名\"; String password = \"密码\"; //3.获取与数据库的连接,Connection代表数据库 Connection connection = DriverManager.getConnection(url,username,password); //4.执行增删改查 //4.1获取执行sql的命令对象statement Statement statement = connection.createStatement(); ////4.2执行sql语句 String sql = \"Select * from beauty\"; ResultSet resultSet = statement.executeQuery(sql); //返回的结果集 //statement.executeQuery(sql);//执行查询语句 //statement.executeUpdate(sql);//执行增删改语法，返回受影响行数 //statement.execute(sql);//执行任何sql语句 while(resultSet.next())&#123; System.out.println(\"id=\"+resultSet.getObject(\"id\")); System.out.println(\"name=\"+resultSet.getObject(\"name\")); System.out.println(\"sex=\"+resultSet.getObject(\"sex\")); System.out.println(\"------------------------\"); &#125; //5.释放连接 resultSet.close(); statement.close(); connection.close(); &#125;&#125; 注：1.useUnicode=true&amp;characterEncoding=utf8作用：指定字符的编码，解码格。例如mysql数据库用的是gbk编码，而项目数据库用的是utf-8编码 2.useSSl=true或falseMySQL在高版本需要指明是否进行SSL连接。 SSL协议提供服务主要： 认证用户服务器，确保数据发送到正确的服务器； . 加密数据，防止数据传输途中被窃取使用； 维护数据完整性，验证数据在传输过程中是否丢失； 3.serverTimezone=GMT%2B8mysql-connector-java 6 中的特性，相比mysql-connector-java 5 多了一个时区：serverTimezone serverTimezone=GMT%2B8 //指定时区为北京时间东八区 4.为什么不使用注册驱动通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类都包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例。 注：使用DriverManager.registerDriver(com.mysql.cj.jdbc.Driver)来注册驱动 JDBC常见APIJDBC API是一系列的接口，它统一和规范了应用程序与数据库的连接、执行SQL语句，并到得到返回结果等各类操作。声明在java.sql与javax.sql包中。 DriverManager 驱动管理类​ registDriver(Driver对象):注册驱动（不推荐使用） ​ getConnection(url,user,pwd):获取连接 Connection 连接对象接口​ createStatement():生产命令对象 ​ prepareStatement(sql):生产预编译命令对象 Statement 命令对象接口​ executeUpdate(sql):执行增删改语句，返回受影响的行数 ​ executeQuery(sql):执行查询语句，返回结果集 ​ execute(sql):执行任意sql语句，返回boolean PrepareStatement预编译命令对象接口​ executeUpdate(sql):执行增删改语句，返回受影响的行数 ​ executeQuery(sql):执行查询语句，返回结果集 ​ execute(sql):执行任意sql语句，返回boolean ​ setXX(占位符索引，占位符的值):设置对应索引的占位符的值，类型为Object类型 ResultSet结果对象接口​ next():下移一行，返回当前行是否有值 ​ previous():上移一行，返回当前是否有值 ​ getXX(列索引||列名||别名):返回对应列的值，接受类型为XX ​ getObject(列索引||列名||别名):返回对应列的值，接受类型为Object 三.获取连接（包含JDBC编写的前三步）1.加载驱动加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名 Class.forName(“com.mysql.cj.jdbc.Driver”); 注： java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。 在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现。 eg: Oracle的驱动：oracle.jdbc.driver.OracleDriver ，mySql的驱动： com.mysql.cj.jdbc.Driver 2.URL JDBC URL 向驱动程序提供个一个识别数据源的方法，根据URL先前载入的驱动程序便可以找到对应的数据源并且实现数据库连接。 JDBC URL的标准由三部分组成，各部分间用冒号分隔。 jdbc:子协议:名称 ，协议：JDBC URL中的协议总是jdbc 子协议：子协议用于标识一个数据库驱动程序 名称：一种标识数据库的方法。名称可以依不同的子协议而变化，用名称的目的是为了定位数据库提供足够的信息。包含主机名(对应服务端的ip地址)，端口号，数据库名 常见MySQL连接URL编写方式： jdbc:mysql://主机名称:mysql:服务端口号/数据库名称?参数=值&amp;参数=值 jdbc:mysql://localhost:3306/lalala?useUnicode=true&amp;characterEncoding=utf8 jdbc:mysql://localhost:3306/lalala?user=用户名&amp;password=密码 jdbc:mysql://localhost:3306/lalala 用户名和密码： user,password可以用“属性名=属性值”方式告诉数据库 eg：String username = “账户名” String password = “密码”; 可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接 3.连接方式：连接方式112345678910111213141516public void testConnection1() &#123; try &#123; //1.数据库连接的4个基本要素： String url = \"jdbc:mysql://localhost:3306/test\"; String user = \"root\"; String password = \"123456\"; String driverClass= \"com.mysql.cj.jdbc.Driver\"; //2.加载驱动 Class.forName(driverName); //3.获取连接 Connection connection = DriverManager.getConnection(url, user, password); System.out.println(connection); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 连接方式212345678910111213141516171819public void testConnection2() throws Exception &#123; //1.加载配置文件 InputStream is = ConnectionTest.class.getClassLoader().getResourceAsStream(\"jdbc.properties\"); Properties pros = new Properties(); pros.load(is); //2.读取配置信息 String user = pros.getProperty(\"user\"); String password = pros.getProperty(\"password\"); String url = pros.getProperty(\"url\"); String driverClass = pros.getProperty(\"driverClass\"); //3.加载驱动 Class.forName(driverClass); //4.获取连接 Connection connection =DriverManager.getConnection(url,user,password); System.out.println(connection); &#125; 配置文件在工程的src目录下建立：jdbc.properties 1234user&#x3D;rootpassword&#x3D;123456url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;lalaladriverClass&#x3D;com.mysql.cj.jdbc.Driver 为什么使用配置文件： 实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码 如果修改了配置信息，省去重新编译的过程。 四.使用PreparedStatement实现CRUD操作4.1 操作和访问数据库 数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。一个数据库连接就是一个Socket连接。 在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式： Statement：用于执行静态 SQL 语句并返回它所生成结果的对象。 PrepatedStatement：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。 CallableStatement：用于执行 SQL 存储过程 4.2 使用Statement操作数据表 通过调用 Connection 对象的 createStatement() 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。 Statement 接口中定义了下列方法用于执行 SQL 语句： int update = statement.executeUpdate(sql); 执行更新操作INSERT、UPDATE、DELETE ResultSet resultSet = statement.executeQuery(sql); 执行查询操作SELECT 弊端： 存在拼串操作，繁琐 eg: 1String sql = \"SELECT user,password FROM user_table WHERE USER = '\" + userName + \"' AND PASSWORD = '\" + password 存在SQL注入问题 解决方法：对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了 4.3 JDBC连接的工具类功能 获取连接 释放资源 样例：123456789101112131415161718192021222324252627282930313233343536373839public class JDBCUtile&#123; //获取可用的连接对象 static String user static String password static String url static String driverClass try&#123; Properties info = new Properties; info.load(new FileInputStream(\"src\\\\jdbc.properties\")); user = pros.getProperty(\"user\"); password = pros.getProperty(\"password\"); url = pros.getProperty(\"url\"); driverClass = pros.getProperty(\"driverClass\"); Class.forName(driverClass); &#125;catch(Exception e)&#123; throw new RuntimeException(); &#125; public static Connection getConnection() throws Exception&#123; return DriverManager.getConnection(url,user,password); &#125; //释放资源 public static void close(ResultSet set,Statement statement,Connection connection)&#123; try&#123; if(set != null)&#123; set.close(); &#125; if(statament != null)&#123; statement.close(); &#125; if(connection != null)&#123; connection.close(); &#125; &#125;catch&#123; throw new RuntimeException(); &#125; &#125;&#125; 4.4 使用PreparedStatement简介： PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句 可以通过调用 Connection 对象的 preparedStatement(String sql) 方法获取 PreparedStatement 对象 PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值 相对Statement的优势： 代码的可读性和可维护性 更好的性能，预编译语句可被重复调用，储存在缓存中，节省反复编译的时间。 防止 SQL 注入 实现增、删、改操作1234567891011121314151617181920212223242526//通用的增、删、改操作（体现一：增、删、改 ； 体现二：针对于不同的表） public int update(String sql,Object ... args)&#123; Connection conn = null; PreparedStatement ps = null; try &#123; //1.获取数据库的连接 conn = JDBCUtils.getConnection(); //2.获取PreparedStatement的实例 (或：预编译sql语句) ps = conn.prepareStatement(sql); //3.填充占位符 for(int i = 0;i &lt; args.length;i++)&#123; ps.setObject(i + 1, args[i]); &#125; int update = statement.executeUpdate(); return update; //4.执行sql语句 ps.execute(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; //5.关闭资源 JDBCUtils.close(conn, ps); &#125; &#125; 实现查询1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 通用的针对于不同表的查询:返回一个对象 public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz, String sql, Object... args) &#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; // 1.获取数据库连接 conn = JDBCUtils.getConnection(); // 2.预编译sql语句，得到PreparedStatement对象 ps = conn.prepareStatement(sql); // 3.填充占位符 for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; // 4.执行executeQuery(),得到结果集：ResultSet rs = ps.executeQuery(); // 5.得到结果集的元数据：ResultSetMetaData ResultSetMetaData rsmd = rs.getMetaData(); // 6.1通过ResultSetMetaData得到columnCount,columnLabel；通过ResultSet得到列值 int columnCount = rsmd.getColumnCount(); if (rs.next()) &#123; T t = clazz.newInstance(); for (int i = 0; i &lt; columnCount; i++) &#123;// 遍历每一个列 // 获取列值 Object columnVal = rs.getObject(i + 1); // 获取列的别名:列的别名，使用类的属性名充当 String columnLabel = rsmd.getColumnLabel(i + 1); // 6.2使用反射，给对象的相应属性赋值 Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t, columnVal); &#125; return t; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 7.关闭资源 JDBCUtils.close(conn, ps, rs); &#125; return null;&#125; 4.5 ResultSet与ResultSetMetaDataResultSet 查询需要调用PreparedStatement 的 executeQuery() 方法，查询结果是一个ResultSet 对象 ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商提供实现 ResultSet 返回的实际上就是一张数据表。有一个指针指向数据表的第一条记录的前面。 ResultSet 对象维护了一个指向当前数据行的游标，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行。调用 next()方法检测下一行是否有效。若有效，该方法返回 true，且指针下移。相当于Iterator对象的 hasNext() 和 next() 方法的结合体。 当指针指向一行时, 可以通过调用 getXxx(int index) 或 getXxx(int columnName) 获取每一列的值。 例如: getInt(1), getString(“name”) 注意：Java与数据库交互涉及到的相关Java API中的索引都从1开始 ResultSetMetaData 可用于获取关于 ResultSet 对象中列的类型和属性信息的对象 ResultSetMetaData meta = rs.getMetaData(); getColumnName(int column)：获取指定列的名称 getColumnLabel(int column)：获取指定列的别名 getColumnCount()：返回当前 ResultSet 对象中的列数。 isNullable(int column)：指示指定列中的值是否可以为 null。 4.6 释放资源： 释放ResultSet, Statement,Connection 可以在finally中关闭，保证及时其他代码出现异常，资源也一定能被关闭。 ORM思想(object relational mapping) 一个数据表对应一个java类 表中的一条记录对应java类的一个对象 表中的一个字段对应java类的一个属性 五.JDBC事务处理： 数据一旦提交，则不可回滚 数据提交条件： 当一个连接对象被创建时，默认为自动提交事务：每次执行一个SQL语句时，如果执行成功，就会自动向数据库提交 关闭数据库连接时，数据就会自动提交：同一个事务的多个操作必须在同一连接下 JDBC程序中为了让多个SQL语句作为一个事务执行采取的方法： 调用Connection对象的setAutoCommit(false); 来取消自动提交事务 在所有SQl语句都成功执行后，调用Commit();方法提交事务 在出现异常时，调用rollback();方法回滚事务 注：若此时 Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态 setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。 案例：用户AA向用户BB转账10012345678910111213141516171819202122232425262728293031323334353637public void testJDBCTransaction() &#123; Connection conn = null; try &#123; // 1.获取数据库连接 conn = JDBCUtils.getConnection(); // 2.开启事务 conn.setAutoCommit(false); // 3.进行数据库操作 String sql1 = \"update user_table set balance = balance - 100 where user = ?\"; update(conn, sql1, \"AA\"); // 模拟网络异常 //System.out.println(10 / 0); String sql2 = \"update user_table set balance = balance + 100 where user = ?\"; update(conn, sql2, \"BB\"); // 4.若没有异常，则提交事务 conn.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); // 5.若有异常，则回滚事务 try &#123; conn.rollback(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125; finally &#123; try &#123; //6.恢复每次DML操作的自动提交功能 conn.setAutoCommit(true); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; //7.关闭连接 JDBCUtils.closeResource(conn, null, null); &#125; &#125; 其中，对数据库操作的方法为： 1234567891011121314151617181920//使用事务以后的通用的增删改操作（version 2.0）public void update(Connection conn ,String sql, Object... args) &#123; PreparedStatement ps = null; try &#123; // 1.获取PreparedStatement的实例 (或：预编译sql语句) ps = conn.prepareStatement(sql); // 2.填充占位符 for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; // 3.执行sql语句 ps.execute(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 4.关闭资源 JDBCUtils.closeResource(null, ps); &#125;&#125; 六.批量插入需要批量插入的情景 一个SQL语句的批量传参 多条SQL语句的批量处理 JDBC中批量插入方法 addBatch(String)：添加需要批量处理的SQL语句或是参数 executeBatch()：执行批量处理语句； clearBatch():清空缓存的数据 12345678910111213141516171819202122232425262728293031323334/*mysql服务器默认是关闭批处理的，我们需要通过一个参数，让mysql开启批处理的支持。* ?rewriteBatchedStatements=true 写在配置文件的url后面 */public void testInsert2() throws Exception&#123; long start = System.currentTimeMillis(); Connection conn = JDBCUtils.getConnection(); //1.设置为不自动提交数据 conn.setAutoCommit(false); String sql = \"insert into goods(name)values(?)\"; PreparedStatement ps = conn.prepareStatement(sql); for(int i = 1;i &lt;= 1000000;i++)&#123; ps.setString(1, \"name_\" + i); //1.“攒”sql ps.addBatch(); if(i % 500 == 0)&#123; //2.执行 ps.executeBatch(); //3.清空 ps.clearBatch(); &#125; &#125; //2.提交数据 conn.commit(); long end = System.currentTimeMillis(); System.out.println(\"花费的时间为：\" + (end - start)); JDBCUtils.closeResource(conn, ps); 七.数据库连接池7.1 JDBC数据库连接池的意义 在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤： 在主程序（如servlet、beans）中建立数据库连接 进行sql操作 断开数据库连接 这种模式开发，存在的问题: 普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。数据库的连接资源并没有得到很好的重复利用。若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。 对于每一次数据库连接，使用完后都得断开。否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。 这种开发不能控制被创建的连接对象数，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。 7.2 数据库连接池技术 数据库连接池的基本思想：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。 数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。 优点： 资源重用：避免频繁创建释放，减少系统消耗，提升稳定性。 更快的系统响应：由于数据库连接池在初始化时就创建了一些数据库连接在池中备用，因此在需要连接时，减少了响应时间。 更细腻的资源分配：在数据库连接池中可设置某一应用最大数据库连接数限制，避免独占资源。 避免数据库连接泄露：可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露 7.3 多种开源的数据库连接池 JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现： DBCP 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。速度相对c3p0较快，但因自身存在BUG，Hibernate3已不再提供支持。 C3P0 是一个开源组织提供的一个数据库连接池，速度相对较慢，稳定性还可以。hibernate官方推荐使用 Druid 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不确定是否有BoneCP快 DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池 DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。 注： 数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可 当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。 Druid案例：123456789101112131415import java.sql.Connection;import java.util.Properties;import javax.sql.DataSource;import com.alibaba.druid.pool.DruidDataSourceFactory;public class TestDruid &#123; public static void main(String[] args) throws Exception &#123; Properties pro = new Properties(); pro.load(TestDruid.class.getClassLoader().getResourceAsStream(\"druid.properties\")); DataSource ds = DruidDataSourceFactory.createDataSource(pro); Connection conn = ds.getConnection(); System.out.println(conn); &#125;&#125; 其中，src下的配置文件为：【druid.properties】 123456789url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test?rewriteBatchedStatements&#x3D;trueusername&#x3D;rootpassword&#x3D;123456driverClass&#x3D;com.mysql.cj.jdbc.DriverinitialSize&#x3D;10maxActive&#x3D;20maxWait&#x3D;1000filters&#x3D;wall 八.Apache-DBUtils实现CRUD操作8.1 简介 commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。 API: org.apache.commons.dbutils.QueryRunner org.apache.commons.dbutils.ResultSetHandler org.apache.commons.dbutils.DbUtils 8.2 DbUtils DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下： public static void close(…) throws java.sql.SQLException： DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。 8.3 QueryRunner类 该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。 QueryRunner类提供了两个构造器： 默认的构造器 需要一个 javax.sql.DataSource 来作参数的构造器 QueryRunner类的主要方法： 更新：public int update(Connection conn, String sql, Object… params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。 插入：public T insert(Connection conn,String sql,ResultSetHandler rsh, Object… params) throws SQLException：只支持INSERT语句 批处理： public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句 public T insertBatch(Connection conn,String sql,ResultSetHandler rsh,Object[][] params)throws SQLException：只支持INSERT语句 查询：public Object query(Connection conn, String sql, ResultSetHandler rsh,Object… params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。 测试 12345678910111213// 测试添加@Testpublic void testInsert() throws Exception &#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection(); String sql = \"insert into customers(name,email,birth)values(?,?,?)\"; int count = runner.update(conn, sql, \"何成飞\", \"he@qq.com\", \"1992-09-08\"); System.out.println(\"添加了\" + count + \"条记录\"); JDBCUtils.closeResource(conn, null);&#125; 12345678910111213// 测试删除@Testpublic void testDelete() throws Exception &#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection(); String sql = \"delete from customers where id &lt; ?\"; int count = runner.update(conn, sql,3); System.out.println(\"删除了\" + count + \"条记录\"); JDBCUtils.closeResource(conn, null);&#125; 8.4ResultSetHandler接口及实现类 该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。 ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。 接口的主要实现类： BeanHandler：将结果集中的第一行数据封装到一个对应的JavaBean实例中。 BeanListHandler：将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。 MapHandler：将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。 MapListHandler：将结果集中的每一行数据都封装到一个Map里，然后再存放到List ScalarHandler：查询单个值对象 ColumnListHandler：将结果集中某一列的数据存放到List中。 ArrayHandler：把结果集中的第一行数据转成对象数组。 ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。 测试 123456789101112131415161718/* * 测试查询:查询一条记录 * * 使用ResultSetHandler的实现类：BeanHandler */public void testQueryInstance() throws Exception&#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection(); String sql = \"select id,name,email,birth from customers where id = ?\"; // BeanHandler&lt;Customer&gt; handler = new BeanHandler&lt;&gt;(Customer.class); Customer customer = runner.query(conn, sql, handler, 23); System.out.println(customer); JDBCUtils.closeResource(conn, null);&#125; 12345678910111213141516171819/* * 测试查询:查询多条记录构成的集合 * * 使用ResultSetHandler的实现类：BeanListHandler */public void testQueryList() throws Exception&#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection(); String sql = \"select id,name,email,birth from customers where id &lt; ?\"; // BeanListHandler&lt;Customer&gt; handler = new BeanListHandler&lt;&gt;(Customer.class); List&lt;Customer&gt; list = runner.query(conn, sql, handler, 23); list.forEach(System.out::println); JDBCUtils.closeResource(conn, null);&#125; 123456789101112131415161718192021222324252627282930313233343536/* * 自定义ResultSetHandler的实现类 */public void testQueryInstance1() throws Exception&#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection(); String sql = \"select id,name,email,birth from customers where id = ?\"; ResultSetHandler&lt;Customer&gt; handler = new ResultSetHandler&lt;Customer&gt;() &#123; @Override public Customer handle(ResultSet rs) throws SQLException &#123; System.out.println(\"handle\");// return new Customer(1,\"Tom\",\"tom@126.com\",new Date(123323432L)); if(rs.next())&#123; int id = rs.getInt(\"id\"); String name = rs.getString(\"name\"); String email = rs.getString(\"email\"); Date birth = rs.getDate(\"birth\"); return new Customer(id, name, email, birth); &#125; return null; &#125; &#125;; Customer customer = runner.query(conn, sql, handler, 23); System.out.println(customer); JDBCUtils.closeResource(conn, null);&#125; 123456789101112131415161718192021222324/* * 如何查询类似于最大的，最小的，平均的，总和，个数相关的数据， * 使用ScalarHandler * */public void testQueryValue() throws Exception&#123; QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection(); //测试一：// String sql = \"select count(*) from customers where id &lt; ?\";// ScalarHandler handler = new ScalarHandler();// long count = (long) runner.query(conn, sql, handler, 20);// System.out.println(count); //测试二： String sql = \"select max(birth) from customers\"; ScalarHandler handler = new ScalarHandler(); Date birth = (Date) runner.query(conn, sql, handler); System.out.println(birth); JDBCUtils.closeResource(conn, null);&#125; JDBC总结1234567891011121314151617181920212223242526272829303132333435public void testUpdateWithTx() &#123; Connection conn = null; try &#123; //1.获取连接的操作（ //① 手写的连接：JDBCUtils.getConnection(); //② 使用数据库连接池：C3P0;DBCP;Druid //2.对数据表进行一系列CRUD操作 //① 使用PreparedStatement实现通用的增删改、查询操作//增删改public void update(Connection conn,String sql,Object ... args)&#123;&#125;//查询 public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz,String sql,Object ... args)&#123;&#125; //② 使用dbutils提供的jar包中提供的QueryRunner类 //提交数据 conn.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); try &#123; //回滚数据 conn.rollback(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125;finally&#123; //3.关闭连接等操作 //① JDBCUtils.closeResource(); //② 使用dbutils提供的jar包中提供的DbUtils类提供了关闭的相关操作 &#125;&#125; 九.DAO及相关实现类 DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息。有时也称作：BaseDAO 作用：为了实现功能的模块化，更有利于代码的维护和升级。 【BaseDAO.java】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package com.atguigu.bookstore.dao;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.sql.Connection;import java.sql.SQLException;import java.util.List;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import org.apache.commons.dbutils.handlers.ScalarHandler;/** * 定义一个用来被继承的对数据库进行基本操作的Dao * * @author HanYanBing * * @param &lt;T&gt; */public abstract class BaseDao&lt;T&gt; &#123; private QueryRunner queryRunner = new QueryRunner(); // 定义一个变量来接收泛型的类型 private Class&lt;T&gt; type; // 获取T的Class对象，获取泛型的类型，泛型是在被子类继承时才确定 public BaseDao() &#123; // 获取子类的类型 Class clazz = this.getClass(); // 获取父类的类型 // getGenericSuperclass()用来获取当前类的父类的类型 // ParameterizedType表示的是带泛型的类型 ParameterizedType parameterizedType = (ParameterizedType) clazz.getGenericSuperclass(); // 获取具体的泛型类型 getActualTypeArguments获取具体的泛型的类型 // 这个方法会返回一个Type的数组 Type[] types = parameterizedType.getActualTypeArguments(); // 获取具体的泛型的类型· this.type = (Class&lt;T&gt;) types[0]; &#125; /** * 通用的增删改操作 * * @param sql * @param params * @return */ public int update(Connection conn,String sql, Object... params) &#123; int count = 0; try &#123; count = queryRunner.update(conn, sql, params); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return count; &#125; /** * 获取一个对象 * * @param sql * @param params * @return */ public T getBean(Connection conn,String sql, Object... params) &#123; T t = null; try &#123; t = queryRunner.query(conn, sql, new BeanHandler&lt;T&gt;(type), params); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return t; &#125; /** * 获取所有对象 * * @param sql * @param params * @return */ public List&lt;T&gt; getBeanList(Connection conn,String sql, Object... params) &#123; List&lt;T&gt; list = null; try &#123; list = queryRunner.query(conn, sql, new BeanListHandler&lt;T&gt;(type), params); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return list; &#125; /** * 获取一个但一值得方法，专门用来执行像 select count(*)...这样的sql语句 * * @param sql * @param params * @return */ public Object getValue(Connection conn,String sql, Object... params) &#123; Object count = null; try &#123; // 调用queryRunner的query方法获取一个单一的值 count = queryRunner.query(conn, sql, new ScalarHandler&lt;&gt;(), params); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return count; &#125;&#125; 【BookDAO.java】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.atguigu.bookstore.dao;import java.sql.Connection;import java.util.List;import com.atguigu.bookstore.beans.Book;import com.atguigu.bookstore.beans.Page;public interface BookDao &#123; /** * 从数据库中查询出所有的记录 * * @return */ List&lt;Book&gt; getBooks(Connection conn); /** * 向数据库中插入一条记录 * * @param book */ void saveBook(Connection conn,Book book); /** * 从数据库中根据图书的id删除一条记录 * * @param bookId */ void deleteBookById(Connection conn,String bookId); /** * 根据图书的id从数据库中查询出一条记录 * * @param bookId * @return */ Book getBookById(Connection conn,String bookId); /** * 根据图书的id从数据库中更新一条记录 * * @param book */ void updateBook(Connection conn,Book book); /** * 获取带分页的图书信息 * * @param page：是只包含了用户输入的pageNo属性的page对象 * @return 返回的Page对象是包含了所有属性的Page对象 */ Page&lt;Book&gt; getPageBooks(Connection conn,Page&lt;Book&gt; page); /** * 获取带分页和价格范围的图书信息 * * @param page：是只包含了用户输入的pageNo属性的page对象 * @return 返回的Page对象是包含了所有属性的Page对象 */ Page&lt;Book&gt; getPageBooksByPrice(Connection conn,Page&lt;Book&gt; page, double minPrice, double maxPrice);&#125; 【UserDAO.java】12345678910111213141516171819202122232425262728293031package com.atguigu.bookstore.dao;import java.sql.Connection;import com.atguigu.bookstore.beans.User;public interface UserDao &#123; /** * 根据User对象中的用户名和密码从数据库中获取一条记录 * * @param user * @return User 数据库中有记录 null 数据库中无此记录 */ User getUser(Connection conn,User user); /** * 根据User对象中的用户名从数据库中获取一条记录 * * @param user * @return true 数据库中有记录 false 数据库中无此记录 */ boolean checkUsername(Connection conn,User user); /** * 向数据库中插入User对象 * * @param user */ void saveUser(Connection conn,User user);&#125; 【BookDaoImpl.java】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.atguigu.bookstore.dao.impl;import java.sql.Connection;import java.util.List;import com.atguigu.bookstore.beans.Book;import com.atguigu.bookstore.beans.Page;import com.atguigu.bookstore.dao.BaseDao;import com.atguigu.bookstore.dao.BookDao;public class BookDaoImpl extends BaseDao&lt;Book&gt; implements BookDao &#123; @Override public List&lt;Book&gt; getBooks(Connection conn) &#123; // 调用BaseDao中得到一个List的方法 List&lt;Book&gt; beanList = null; // 写sql语句 String sql = \"select id,title,author,price,sales,stock,img_path imgPath from books\"; beanList = getBeanList(conn,sql); return beanList; &#125; @Override public void saveBook(Connection conn,Book book) &#123; // 写sql语句 String sql = \"insert into books(title,author,price,sales,stock,img_path) values(?,?,?,?,?,?)\"; // 调用BaseDao中通用的增删改的方法 update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(),book.getImgPath()); &#125; @Override public void deleteBookById(Connection conn,String bookId) &#123; // 写sql语句 String sql = \"DELETE FROM books WHERE id = ?\"; // 调用BaseDao中通用增删改的方法 update(conn,sql, bookId); &#125; @Override public Book getBookById(Connection conn,String bookId) &#123; // 调用BaseDao中获取一个对象的方法 Book book = null; // 写sql语句 String sql = \"select id,title,author,price,sales,stock,img_path imgPath from books where id = ?\"; book = getBean(conn,sql, bookId); return book; &#125; @Override public void updateBook(Connection conn,Book book) &#123; // 写sql语句 String sql = \"update books set title = ? , author = ? , price = ? , sales = ? , stock = ? where id = ?\"; // 调用BaseDao中通用的增删改的方法 update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(), book.getId()); &#125; @Override public Page&lt;Book&gt; getPageBooks(Connection conn,Page&lt;Book&gt; page) &#123; // 获取数据库中图书的总记录数 String sql = \"select count(*) from books\"; // 调用BaseDao中获取一个单一值的方法 long totalRecord = (long) getValue(conn,sql); // 将总记录数设置都page对象中 page.setTotalRecord((int) totalRecord); // 获取当前页中的记录存放的List String sql2 = \"select id,title,author,price,sales,stock,img_path imgPath from books limit ?,?\"; // 调用BaseDao中获取一个集合的方法 List&lt;Book&gt; beanList = getBeanList(conn,sql2, (page.getPageNo() - 1) * Page.PAGE_SIZE, Page.PAGE_SIZE); // 将这个List设置到page对象中 page.setList(beanList); return page; &#125; @Override public Page&lt;Book&gt; getPageBooksByPrice(Connection conn,Page&lt;Book&gt; page, double minPrice, double maxPrice) &#123; // 获取数据库中图书的总记录数 String sql = \"select count(*) from books where price between ? and ?\"; // 调用BaseDao中获取一个单一值的方法 long totalRecord = (long) getValue(conn,sql,minPrice,maxPrice); // 将总记录数设置都page对象中 page.setTotalRecord((int) totalRecord); // 获取当前页中的记录存放的List String sql2 = \"select id,title,author,price,sales,stock,img_path imgPath from books where price between ? and ? limit ?,?\"; // 调用BaseDao中获取一个集合的方法 List&lt;Book&gt; beanList = getBeanList(conn,sql2, minPrice , maxPrice , (page.getPageNo() - 1) * Page.PAGE_SIZE, Page.PAGE_SIZE); // 将这个List设置到page对象中 page.setList(beanList); return page; &#125;&#125; 【UserDaoImpl.java】123456789101112131415161718192021222324252627282930313233343536373839【Page.java】package com.atguigu.bookstore.dao.impl;import java.sql.Connection;import com.atguigu.bookstore.beans.User;import com.atguigu.bookstore.dao.BaseDao;import com.atguigu.bookstore.dao.UserDao;public class UserDaoImpl extends BaseDao&lt;User&gt; implements UserDao &#123; @Override public User getUser(Connection conn,User user) &#123; // 调用BaseDao中获取一个对象的方法 User bean = null; // 写sql语句 String sql = \"select id,username,password,email from users where username = ? and password = ?\"; bean = getBean(conn,sql, user.getUsername(), user.getPassword()); return bean; &#125; @Override public boolean checkUsername(Connection conn,User user) &#123; // 调用BaseDao中获取一个对象的方法 User bean = null; // 写sql语句 String sql = \"select id,username,password,email from users where username = ?\"; bean = getBean(conn,sql, user.getUsername()); return bean != null; &#125; @Override public void saveUser(Connection conn,User user) &#123; //写sql语句 String sql = \"insert into users(username,password,email) values(?,?,?)\"; //调用BaseDao中通用的增删改的方法 update(conn,sql, user.getUsername(),user.getPassword(),user.getEmail()); &#125;&#125; 【Page.java】123456789101112131415package com.atguigu.bookstore.beans;import java.util.List;/** * 页码类 * @author songhongkang * */public class Page&lt;T&gt; &#123; private List&lt;T&gt; list; // 每页查到的记录存放的集合 public static final int PAGE_SIZE = 4; // 每页显示的记录数 private int pageNo; // 当前页// private int totalPageNo; // 总页数，通过计算得到 private int totalRecord; // 总记录数，通过查询数据库得到 【User.java】123456789101112package com.atguigu.bookstore.beans;/** * 用户类 * @author songhongkang * */public class User &#123; private Integer id; private String username; private String password; private String email;","categories":[{"name":"后端学习","slug":"后端学习","permalink":"http://moersuo.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"},{"name":"数据库","slug":"后端学习/数据库","permalink":"http://moersuo.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://moersuo.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"生产者消费者模型","slug":"生产者消费者模型","date":"2020-10-08T09:31:50.000Z","updated":"2020-10-12T00:41:30.499Z","comments":true,"path":"2020/10/08/生产者消费者模型/","link":"","permalink":"http://moersuo.github.io/2020/10/08/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"概述：生产者消费者消费者模型是一种并发编程中的常见问题，基于等待/通知机制。其基本思想是有一块缓冲区作为仓库，生产者将产品放入枪库，消费者从仓库中取出产品。这个仓库就是一个阻塞队列，生产者生产的产品不直接给消费者消费而是给阻塞队列。这个阻塞队列目的是解决生产者消费者的强耦合。 解决的实际问题： 生产与消费的速度不匹配 软件开发过程中解耦，使生产者与消费者间的强耦合变成生产者和缓冲区，消费者与缓存区间的弱耦合 需要注意的点： 生产者生产的时候消费者不能消费 消费者消费的时候生产者不能生产 仓库即缓冲区为空时不能消费 缓冲区满时生产者不能生产 案例一：缓冲区法 建立继承自Thread的生产者类和消费者类，和只有产品编号字段及构造方法的产品类 构建缓冲区： 构建一个容器和它的容器计数器 构建加锁的生产者生产的push方法 构建加锁的消费者消费的pop方法 重写生产者及消费者的run方法，加入他们的构造方法 构建main方法，构建一个缓冲区类的container实例对象，并开启生产者和消费者线程 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package multithread.prodeuctor_consumer;// 测试生产者消费者模型--&gt;利用缓冲区解决：管程法//生产者，消费者，产品，缓冲区public class TestPc &#123; public static void main(String[] args) &#123; SynContainer container = new SynContainer(); new Productor(container).start(); new Consumer(container).start(); &#125;&#125;// 生产者class Productor extends Thread&#123; SynContainer container; public Productor(SynContainer container)&#123; this.container = container; &#125; //生产 @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; container.push(new Food(i)); System.out.println(\"生产了\"+i+\"号食物\"); &#125; &#125;&#125;// 消费者class Consumer extends Thread&#123; SynContainer container; public Consumer(SynContainer container)&#123; this.container = container; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"消费了--&gt;\"+container.pop().id+\"号食物\"); &#125; &#125;&#125;//产品class Food&#123; int id; //产品编号 public Food(int id) &#123; this.id = id; &#125;&#125;//缓冲区class SynContainer&#123; //需要一个容器大小 Food[] foods = new Food[10]; //容器计数器 int count = 0; //生产者放入产品 public synchronized void push(Food food)&#123; //如果容器满了，就需要等待消费者消费 while(count == foods.length)&#123; //通知消费者消费，生产等待 try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //如果容器未满，我们需要加入产品 foods[count] = food; count++; //可以通知消费者消费了 this.notifyAll(); &#125; public synchronized Food pop()&#123; //判断能否消费 while(count == 0)&#123; //等待生产者生产，消费者等待 try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //如果可以消费 count--; Food food = foods[count]; //吃完了，通知生产者生产 this.notifyAll(); return food; &#125;&#125; 案例二：信号灯法，标志位解决 构建生产者，消费者，产品类 构建产品类的字段节目，并建立标志位 构建演出与观看方法，标志位为真时表演–观看线程沉睡，为假时观看–表演线程沉睡，演出或观看结束时唤醒其他线程 构建测试类 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package multithread.prodeuctor_consumer;// 测试生产者，消费者问题2：信号灯法，标志位解决public class TestPc2 &#123; public static void main(String[] args) &#123; Tv tv = new Tv(); new actor(tv).start(); new audience(tv).start(); &#125;&#125;//生产者--&gt;演员class actor extends Thread&#123; Tv tv; public actor(Tv tv)&#123; this.tv = tv; &#125; @Override public void run()&#123; for (int i = 0; i &lt; 20; i++) &#123; if(i % 2 == 0)&#123; this.tv.play(\"风骚律师\"); &#125;else&#123; this.tv.play(\"广告\"); &#125; &#125; &#125;&#125;//消费者--&gt;观众class audience extends Thread&#123; Tv tv; public audience(Tv tv)&#123; this.tv = tv; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; this.tv.watch(); &#125; &#125;&#125;//产品--&gt;节目class Tv&#123; //演员录制节目，观众等待 T //观众观看，演员等待 F String program; //表演的节目 boolean flag = true; //表演 public synchronized void play(String program)&#123; if(!flag)&#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(\"演员表演了：\"+program); //通知观众观看 this.notifyAll();//通知唤醒 this.program = program; this.flag = !this.flag; &#125; //观看 public synchronized void watch()&#123; if(flag)&#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(\"观众观看了：\"+program); //通知演员表演 this.notifyAll(); this.flag = !this.flag; &#125;&#125;","categories":[{"name":"后端学习","slug":"后端学习","permalink":"http://moersuo.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"},{"name":"多线程","slug":"后端学习/多线程","permalink":"http://moersuo.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://moersuo.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"剑指offer06：从头到尾打印链表","slug":"剑指offer06：从头到尾打印链表","date":"2020-10-05T08:24:53.000Z","updated":"2020-10-05T09:10:38.341Z","comments":true,"path":"2020/10/05/剑指offer06：从头到尾打印链表/","link":"","permalink":"http://moersuo.github.io/2020/10/05/%E5%89%91%E6%8C%87offer06%EF%BC%9A%E4%BB%8E%E5%A4%B4%E5%88%B0%E5%B0%BE%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/","excerpt":"","text":"题目: 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例： 输入：head = [1,3,2]输出：[2,3,1] 限制： 0 &lt;= 链表长度 &lt;= 10000 法一：使用栈存储思路：当我们看到从尾到头反向输出时，便应该想到这是栈的的典型特征。根据这一特点，我们将使用栈将链表元素顺序倒置。从链表的第一个值开始，依次将每个值压入栈内，然后依次弹出栈内的元素并存储到数组中。 创建一个栈，用于储存链表每个节点的值 创建一个指针，指向链表头结点 当指针指向非空元素时，重复以下操作： 将指针指向的节点的值压入栈内 将指针移到当前节点的下一个节点 获得栈的大小size，创建一个大小为size的数组array 建立一个size次的for循环，每次从栈内弹出一个节点值，存入size中 返回array 代码：123456789101112131415161718192021222324/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int[] reversePrint(ListNode head) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); ListNode temp = head; while (temp != null) &#123; stack.push(temp.val); temp = temp.next; &#125; int size = stack.size(); int[] array = new int[size]; for (int i = 0; i &lt; size; i++) &#123; array[i] = stack.pop(); &#125; return array; &#125;&#125; 复杂度分析： 时间复杂度：O(n)。正向遍历一遍链表，然后从栈弹出全部节点，等于又反向遍历一遍链表。 空间复杂度：O(n)。额外使用一个栈存储链表中的每个节点。 法一.二:使用ArrayList存储思路相同，只不过容器换为ArrayList 代码：123456789101112131415public class Solution &#123; public int[] reversePrint(ListNode head) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while (head != null) &#123; list.add(head.val); head = head.next; &#125; int size = list.size(); int[] array = new int[size]; for (int i = 0; i &lt; size; i++) &#123; array[i] = list.get(size - i -1); &#125; return array; &#125;&#125; 法二：递归思路： 递推阶段： 每次传入 head.next ，以 head == null（即走过链表尾部节点）为递归终止条件，此时直接返回。 回溯阶段： 层层回溯时，将当前节点值加入列表，即tmp.add(head.val)。 最终，将列表 tmp 转化为数组 res ，并返回即可。 代码：123456789101112131415161718192021222324/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; ArrayList&lt;Integer&gt; temp = new ArrayList&lt;Integer&gt;(); public int[] reversePrint(ListNode head) &#123; recur(head); int[] array = new int[temp.size()]; for(int i = 0; i &lt; temp.size();i++)&#123; array[i] = temp.get(i); &#125; return array; &#125; void recur(ListNode head)&#123; if(head == null) return; recur(head.next); temp.add(head.val); &#125;&#125; 复杂度分析： 时间复杂度 O(N)： 遍历链表，递归 N次。 时间复杂度 O(N)： 遍历链表，递归 N次。","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"剑指offer","slug":"算法/剑指offer","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://moersuo.github.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"Leetcode题解09 回文数","slug":"Leetcode题解09-回文数","date":"2020-10-04T03:36:19.000Z","updated":"2020-10-04T06:40:37.014Z","comments":true,"path":"2020/10/04/Leetcode题解09-回文数/","link":"","permalink":"http://moersuo.github.io/2020/10/04/Leetcode%E9%A2%98%E8%A7%A309-%E5%9B%9E%E6%96%87%E6%95%B0/","excerpt":"","text":"Leetcode题解09 ：回文数题目： 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例： 输入: 121输出: true 输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。 官方法一：反转一半数字思路： 映入脑海的第一个想法便是将整个数字反转，再与原数字比较，如果他们相同则数字为回文数，但这可能会使反转后的数字大于int.max,产生整数溢出问题。 由此我们可以考虑反转整数的一半，回文数的后半部分反转后应该与前半部分相等。 首先处理临界问题 对于数字 1221，如果执行 1221 % 10，我们将得到最后一位数字 1，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以 10 的余数，122 % 10 = 2，就可以得到倒数第二位数字。如果我们把最后一位数字乘以 10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了我们想要的反转后的数字。如果继续这个过程，我们将得到更多位数的反转数字。 判断反转数字是否达到原始数字的一半：由于整个过程我们不断将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于或等于反转后的数字时，就意味着我们已经处理了一半位数的数字了。若出现入1321这样的情况，则非回文数，不影响结果。 代码:123456789101112131415161718192021222324class Solution &#123;public: bool isPalindrome(int x) &#123; // 特殊情况： // 如上所述，当 x &lt; 0 时，x 不是回文数。 // 同样地，如果数字的最后一位是 0，为了使该数字为回文， // 则其第一位数字也应该是 0 // 只有 0 满足这一属性 if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) &#123; return false; &#125; int revertedNumber = 0; while (x &gt; revertedNumber) &#123; revertedNumber = revertedNumber * 10 + x % 10; x /= 10; &#125; // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。 // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123， // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。 return x == revertedNumber || x == revertedNumber / 10; &#125;&#125;; 复杂度分析：时间复杂度：O(log n)，对于每次迭代，我们会将输入除以 10，因此时间复杂度为O(logn)。空间复杂度：O(1)。我们只需要常数空间存放若干变量。 法二：数学解法思路：通过取整和取余操作获取整数中对应的数字进行比较。 举个例子：1221 这个数字。 通过计算 1221 / 1000， 得首位1 通过计算 1221 % 10， 可得末位 1 进行比较 再将 22 取出来继续比较 代码:1234567891011121314151617class Solution &#123; public boolean isPalindrome(int x) &#123; //边界判断 if (x &lt; 0) return false; int div = 1; // while (x / div &gt;= 10) div *= 10; while (x &gt; 0) &#123; int left = x / div; int right = x % 10; if (left != right) return false; x = (x % div) / 10; div /= 100; &#125; return true; &#125;&#125; 法三:整数转字符串(看个乐)代码:123456class Solution &#123; public boolean isPalindrome(int x) &#123; String reversedStr = (new StringBuilder(x + \"\")).reverse().toString(); return (x + \"\").equals(reversedStr); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode题解","slug":"算法/Leetcode题解","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://moersuo.github.io/tags/Leetcode%E9%A2%98%E8%A7%A3/"}]},{"title":"剑指offer 05替换空格","slug":"剑指offer-05替换空格","date":"2020-10-02T08:09:27.000Z","updated":"2020-10-04T06:42:23.900Z","comments":true,"path":"2020/10/02/剑指offer-05替换空格/","link":"","permalink":"http://moersuo.github.io/2020/10/02/%E5%89%91%E6%8C%87offer-05%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/","excerpt":"","text":"题目： 请实现一个函数，把字符串 s 中的每个空格替换成”%20”。 示例： 输入：s = “We are happy.”输出：”We%20are%20happy.” 限制： 0 &lt;= s 的长度 &lt;= 10000 官方法一：思路：由于每次替换从 1 个字符变成 3 个字符，使用字符数组可方便地进行替换。建立字符数组地长度为 s 的长度的 3 倍，这样可保证字符数组可以容纳所有替换后的字符。 1.创建字符数组，其长度为length * 3 2.初始化size为0，size表示替换后的字符串的长度 3.从左到右遍历字符串s 利用charAt方法获得s的当前字符c 如果c为空格，则利用size的三次自增使得array[size] = “%”,array[size+1] = “2”,array[size+2] = “0”,且size增加3 如果c不是空格，则另array[size] = c，且size加1 4.遍历结束后，size的值等于替换后字符串的长度，从array的前size个字符创建新字符串，并返回 代码：12345678910111213141516171819class Solution &#123; public String replaceSpace(String s) &#123; int length = s.length(); char[] array = new char[length * 3]; int size = 0; for (int i = 0; i &lt; length; i++) &#123; char c = s.charAt(i); if (c == ' ') &#123; array[size++] = '%'; array[size++] = '2'; array[size++] = '0'; &#125; else &#123; array[size++] = c; &#125; &#125; String newStr = new String(array, 0, size); return newStr; &#125;&#125; 复杂度分析： 时间复杂度：O(n)。遍历字符串 s 一遍。 空间复杂度：O(n)。额外创建字符数组，长度为 s 的长度的 3 倍。 法二：思路：和上面差不多，就是把字符串中的每个字符一个个添加到StringBuilder中，如果遇到空格就把他换成%20。 代码：12345678910public String replaceSpace(String s) &#123; StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; s.length(); i++) &#123; if (s.charAt(i) == ' ') stringBuilder.append(\"%20\"); else stringBuilder.append(s.charAt(i)); &#125; return stringBuilder.toString(); &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"剑指offer","slug":"算法/剑指offer","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://moersuo.github.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"线程的五大状态","slug":"线程的五大状态","date":"2020-09-29T09:26:52.000Z","updated":"2020-10-04T06:41:53.331Z","comments":true,"path":"2020/09/29/线程的五大状态/","link":"","permalink":"http://moersuo.github.io/2020/09/29/%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%94%E5%A4%A7%E7%8A%B6%E6%80%81/","excerpt":"","text":"概述：线程的五大状态为：创建状态，就绪状态，阻塞状态，运行状态，死亡状态 new: Thread t = new Thread() 线程一旦创建，就进入到了创建状态。 就绪状态： 当调用start()方法，线程立即进入就绪状态，但不意味着立即调度执行。 运行状态：进入运行状态，线程才真正执行线程体的代码块。 阻塞状态： 当调用sleep，wait或同步锁定时，线程进入阻塞状态，就是代码不往下执行，阻塞事件解除后，重新进入就绪状态，等待cpu调度执行。 dead：线程中断或结束，一旦进入死亡状态，就不能再次启动。 停止线程：1.不推荐使用JDK提供的stop(),destory()方法 2.最好让线程自己停下来 3.建议使用一个标志位进行终止变量，当flag = false 时，终止线程运行。 样例：123456789101112131415161718192021222324252627282930package multithread.state;public class TestStop implements Runnable&#123; //1.设置1个标识位 private boolean flag = true; @Override public void run()&#123; int i =0; while(flag)&#123; System.out.println(\"run...Thread\"+i++); &#125; &#125; //2.设置一个公开的方法停止线程，转换标识位 public void stop()&#123; this.flag = false; &#125; public static void main(String[] args)&#123; TestStop testStop = new TestStop(); new Thread(testStop).start(); for (int i = 0; i &lt; 1000; i++) &#123; System.out.println(\"lalala\"+i); if(i == 900)&#123; //调用stop方法切换标识为，让线程停止 testStop.stop(); System.out.println(\"线程该停止了\"); &#125; &#125; &#125;&#125; 线程休眠： sleep(时间) 指定当前线程阻塞的毫秒数； sleep存在异常interruptedException; sleep时间达到后线程进入就绪状态 sleep可以模拟网络延时，倒计时等。 每个对象都有一个锁，sleep不会释放锁。 样例1：模拟抢票1234567891011121314151617181920212223242526package multithread.state;// 模拟抢票public class TestSleep implements Runnable&#123; // 票数 private int ticketNums = 10; public void run()&#123; while(true)&#123; if(ticketNums &lt;= 0) &#123; break; &#125; System.out.println(Thread.currentThread().getName()+\"抢到了第\"+ticketNums--+\"张票\"); &#125; // 模拟延时 try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args)&#123; TestSleep ticket = new TestSleep(); new Thread(ticket,\"小明\").start(); new Thread(ticket,\"小王\").start(); new Thread(ticket,\"小张\").start(); &#125;&#125; 样例2：模拟倒计时123456789101112131415161718192021package multithread.state;//模拟倒计时public class TestSleep2 &#123; public static void turndown() throws InterruptedException &#123; int num = 10; while(true)&#123; Thread.sleep(1000); System.out.println(num--); if(num &lt; 0)&#123; break; &#125; &#125; &#125; public static void main(String[] args)&#123; try &#123; turndown(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 线程礼让： 礼让线程，让当前正在执行的线程暂停，但不阻塞。 将线程从运行状态转为就绪状态 让cpu重新调度，礼让不一定成功，看cpu心情。 样例： 1234567891011121314151617package multithread.state;public class TestYield&#123; public static void main(String[] args )&#123; MyYield testYield= new MyYield(); new Thread(testYield,\"1\").start(); new Thread(testYield,\"2\").start(); &#125;&#125;class MyYield implements Runnable&#123; @Override public void run()&#123; System.out.println(Thread.currentThread().getName()+\"开始运行\"); Thread.yield(); System.out.println(Thread.currentThread().getName()+\"停止运行\"); &#125;&#125; 线程强制执行： 某一个线程对象可以一直独占资源，其他线程阻塞，一直到该线程的程序执行结束。 可以想象成插队 123456789101112131415161718192021package multithread.state;public class TestJoin implements Runnable&#123; @Override public void run()&#123; for(int i = 0; i &lt; 1000; i++)&#123; System.out.println(\"我是\"+i); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; TestJoin testJoin = new TestJoin(); Thread thread = new Thread(testJoin); thread.start(); for(int i = 0; i &lt; 1000; i++)&#123; if(i == 200)&#123; thread.join(); &#125; System.out.println(\"你是\"+i); &#125; &#125;&#125; 观察线程状态：12345678910111213141516171819202122232425262728293031323334package multithread.state;import javax.swing.*;//观察线程状态public class TestState &#123; public static void main(String[] args) throws InterruptedException &#123; Thread thread = new Thread(()-&gt;&#123; for(int i = 0; i &lt; 5; i++)&#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(\"lalala\"); &#125;); //观察状态 Thread.State state = thread.getState(); System.out.println(state); // NEW //观察启动后 thread.start(); state = thread.getState(); System.out.println(state); //RUN while(state != Thread.State.TERMINATED)&#123;//只要线程不停止，就一直输出状态 Thread.sleep(100); state = thread.getState();//更新线程状态 System.out.println(state);//输出状态 &#125; &#125;&#125; ​","categories":[{"name":"后端学习","slug":"后端学习","permalink":"http://moersuo.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"},{"name":"多线程","slug":"后端学习/多线程","permalink":"http://moersuo.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://moersuo.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"剑指offer 04二维数组中的查找","slug":"剑指offer-04二维数组中的查找","date":"2020-09-29T08:26:50.000Z","updated":"2020-10-04T06:42:12.115Z","comments":true,"path":"2020/09/29/剑指offer-04二维数组中的查找/","link":"","permalink":"http://moersuo.github.io/2020/09/29/%E5%89%91%E6%8C%87offer-04%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/","excerpt":"","text":"题目： 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例：现有矩阵matrix如下 [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 限制： 0 &lt;= n &lt;= 1000 0 &lt;= m &lt;= 1000 官方法一：暴力思路：在不考虑二维数组已经排好序的情况下，直接遍历整个二维数组的每一个元素，判断目标值是否在二维数组中存在。 注：二维数组的行列长度可用 int rows = matrix.length, columns = matrix[0].length; 表示 代码：12345678910111213141516class Solution &#123; public boolean findNumberIn2DArray(int[][] matrix, int target) &#123; if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123; return false; &#125; int rows = matrix.length, columns = matrix[0].length; for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; columns; j++) &#123; if (matrix[i][j] == target) &#123; return true; &#125; &#125; &#125; return false; &#125;&#125; 复杂度分析： 时间复杂度：O(nm)。二维数组中的每个元素都被遍历，因此时间复杂度为二维数组的大小。 空间复杂度：O(n)。 官方法二：线性查找思路：由于给的的数组为有序的，因此每当访问到一个元素时便可排除部分元素。 从二维数组的右上角开始查找。如果当前元素等于目标值，则返回 true。如果当前元素大于目标值，则移到左边一列。如果当前元素小于目标值，则移到下边一行。 1.若数组为空，返回false 2.初始化行下标为0，列下标为二维数组的列数-1 3.重复以下步骤，直到行下标或列下标超出边界 获得当前下标位置的元素 num如果 num 和 target 相等，返回 true如果 num 大于 target，列下标减 1如果 num 小于 target，行下标加 1 4.循环执行完毕后仍未找到元素等于目标值，则说明不存在这样的元素，返回false。 1234567891011121314151617181920class Solution &#123; public boolean findNumberIn2DArray(int[][] matrix, int target) &#123; if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123; return false; &#125; int rows = matrix.length, columns = matrix[0].length; int row = 0, column = columns - 1; while (row &lt; rows &amp;&amp; column &gt;= 0) &#123; int num = matrix[row][column]; if (num == target) &#123; return true; &#125; else if (num &gt; target) &#123; column--; &#125; else &#123; row++; &#125; &#125; return false; &#125;&#125; 复杂度分析：时间复杂度：O(n+m)。访问到的下标的行最多增加 n 次，列最多减少 m 次，因此循环体最多执行 n + m 次。空间复杂度：O(1)。","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"剑指offer","slug":"算法/剑指offer","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://moersuo.github.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"剑指offer 03数组中重复的数字","slug":"剑指offer-03数组中重复的数字","date":"2020-09-28T12:06:24.000Z","updated":"2020-10-04T06:40:22.930Z","comments":true,"path":"2020/09/28/剑指offer-03数组中重复的数字/","link":"","permalink":"http://moersuo.github.io/2020/09/28/%E5%89%91%E6%8C%87offer-03%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/","excerpt":"","text":"题目： 找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字 示例： 123输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 限制： 2 &lt;= n &lt;= 100000 java：法一 使用集合set思路：由于只需要找出数组中任意一个重复的数字，因此遍历数组，遇到重复的数字即返回。为了判断一个数字是否重复遇到，使用集合存储已经遇到的数字，如果遇到的一个数字已经在集合中，则当前的数字是重复数字。 1.初始化集合为空集合，重复的数字 pepeat = -1 2.遍历数组中的每个元素，尝试将每个元素添加入集合中。若添加失败，则证明该元素已在集合中，将元素的值赋给repeat，结束循环。 3.返回repeat 代码：12345678910111213class Solution &#123; public int findRepeatNumber(int[] nums) &#123; Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); int repeat = -1; for (int num : nums) &#123; if (!set.add(num)) &#123; repeat = num; break; &#125; &#125; return repeat; &#125;&#125; 复杂度分析： 时间复杂度：O(n)：遍历数组一遍。使用哈希集合（HashSet），添加元素的时间复杂度为 O(1)，故总的时间复杂度是 O(n)。 空间复杂度：O(n)。不重复的每个元素都可能存入集合，因此占用 O(n) 额外空间。 法二：使用临时数组思路：我们可以申请一个临时数组temp，因为nums元素中的每个元素的大小都在0~n-1之间，所以我们可以把nums中元素的值和临时数组temp建立映射关系，就是nums中元素的值是几，我们就把temp中对应的位置值加1，当temp某个位置的值大于1的时候，就表示出现了重复，我们直接返回即可 12345678910public int findRepeatNumber(int[] nums) &#123; int length = nums.length; int[] temp = new int[length]; for (int i = 0; i &lt; length; i++) &#123; temp[nums[i]]++; if (temp[nums[i]] &gt; 1) return nums[i]; &#125; return -1; &#125; 法三：原地置换思路：如果没有重复数字，那么正常排序后，数字i应该在下标为i的位置，所以思路是重头扫描数组，遇到下标为i的数字如果不是i的话，（假设为m),那么我们就拿与下标m的数字交换。在交换过程中，如果有重复的数字发生，那么终止返回ture 12345678910111213141516class Solution &#123; public int findRepeatNumber(int[] nums) &#123; int temp; for(int i=0;i&lt;nums.length;i++)&#123; while (nums[i]!=i)&#123; if(nums[i]==nums[nums[i]])&#123; return nums[i]; &#125; temp=nums[i]; nums[i]=nums[temp]; nums[temp]=temp; &#125; &#125; return -1; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"剑指offer","slug":"算法/剑指offer","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://moersuo.github.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"剑指offer 22链表中倒数第k个节点","slug":"剑指offer-22链表中倒数第k个节点","date":"2020-09-27T13:58:22.000Z","updated":"2020-10-04T06:42:31.234Z","comments":true,"path":"2020/09/27/剑指offer-22链表中倒数第k个节点/","link":"","permalink":"http://moersuo.github.io/2020/09/27/%E5%89%91%E6%8C%87offer-22%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/","excerpt":"","text":"题目： 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。 实例： 123给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.返回链表 4-&gt;5. java：双指针解题思路： 利用双指针我们可以不考虑链表总长度，快指针先走k步，再让双指针同时前进，当快指针指向null时，慢指针剩下的部分即为所求值 1.初始化：建立快慢指针，均指向头结点 2.快指针向前走k步，慢指针不动 3.构建循环，双指针同时向前移动，当快指针为null跳出时，慢指针与尾结点距离为k-1，是倒数第k个节点。 4.返回慢指针 注意考虑边界问题 1）head为空指针 2）输入参数k为0 3）k大于链表长度 12345678910111213141516171819class Sloution&#123; public ListNode getKthFromEnd(ListNode head, int k) &#123; //边界问题：head为空指针，输入的参数k为0 if(head == null || k == 0) return null; ListNode fast = head,slow = head; for(int i = 0; i&lt; k ; i++)&#123; if(fast == null &amp;&amp; i &lt; k)&#123; // 边界问题：k大于链表长度 return null; &#125; fast = fast.next; &#125; while(fast!=null)&#123; fast = fast.next; slow = slow.next; &#125; return slow; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"剑指offer","slug":"算法/剑指offer","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://moersuo.github.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"三种方式实现多线程","slug":"三种方式实现多线程","date":"2020-09-27T06:19:28.000Z","updated":"2020-09-27T06:20:11.109Z","comments":true,"path":"2020/09/27/三种方式实现多线程/","link":"","permalink":"http://moersuo.github.io/2020/09/27/%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"java实现多线程的三种方式继承Thread类，实现Runnable接口，实现callable接口 *继承Thread类子类继承Thead类具备多线程能力 启动线程：子类对象.start() 不建议使用：避免OOP单继承局限性 12345678910111213141516public class Thread1 extends Thread&#123; @Override // 使用继承thread方法创建多线程 public void run()&#123; for(int i = 0; i &lt; 20; i++)&#123; System.out.println(\"我在执行分支任务\"+i); &#125; &#125; public static void main(String[] args)&#123; Thread1 thread1 = new Thread1(); thread1.start(); for(int i = 0; i &lt; 20; i++)&#123; System.out.println(\"我在执行主线任务\"+i); &#125; &#125;&#125; *实现Runnable接口实现接口Runnable具有多线程能力 启动线程：传入目标对象+Thread对象.start() 推荐使用，避免单继承局限性，灵活方便，方便同一个对象被多个线程使用 123456789101112131415161718public class Runnable1 implements Runnable&#123; @Override // 使用实现Runnable方法创建多线程 public void run()&#123; for(int i = 0; i &lt; 20; i++)&#123; System.out.println(\"我在执行分支任务\"+i); &#125; &#125; public static void main(String[] args)&#123; Runnable1 Runnable1 = new Runnable1(); //Thread thread = new Thread(Runnable1); //thread.start(); new Thread(Runnable1).start(); for(int i = 0; i &lt; 20; i++)&#123; System.out.println(\"我在执行主线任务\"+i); &#125; &#125;&#125; *实现Callable接口1.实现callable接口需要返回值类型 2.重写call方法，需要抛出异常 3.创建目标对象 4.创建执行服务：ExecutorService ser =Executors.newFixedThreadPool(1); 5.提交执行：Futureresult1=ser.submit(t1); 6.获取结果：bollean r1 = result1.get() 7.关闭服务：ser.shutdownNow(); 1234567891011121314151617181920212223242526272829package course.multithread.callable;import java.util.concurrent.*;public class CallableTest implements Callable&lt;Boolean&gt; &#123; @Override // 使用实现callable方法创建多线程 public Boolean call()&#123; for(int i = 0; i &lt; 20; i++)&#123; System.out.println(\"我在执行分支任务\"+i); &#125; return true; &#125; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; CallableTest t1= new CallableTest(); //创建执行服务： ExecutorService ser = Executors.newFixedThreadPool(1); //提交执行： Future&lt;Boolean&gt; r1 = ser.submit(t1); //获取结果： boolean rs1 = r1.get(); System.out.println(rs1); //关闭服务： ser.shutdownNow(); for(int i = 0; i &lt; 20; i++)&#123; System.out.println(\"我在执行主线任务\"+i); &#125; &#125;&#125;","categories":[{"name":"后端学习","slug":"后端学习","permalink":"http://moersuo.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"},{"name":"多线程","slug":"后端学习/多线程","permalink":"http://moersuo.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://moersuo.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Linux下JDK安装问题","slug":"Linux下JDK安装问题","date":"2020-08-17T01:25:27.000Z","updated":"2020-08-17T01:26:35.235Z","comments":true,"path":"2020/08/17/Linux下JDK安装问题/","link":"","permalink":"http://moersuo.github.io/2020/08/17/Linux%E4%B8%8BJDK%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/","excerpt":"","text":"新的linux环境下配置JDK环境出现-bash: /usr/local/jdk1.8/jdk1.8.0_181/bin/java: /lib/ld-linux.so.2: bad ELF interpreter: No such file or directory解决方法： 安装glibc.i686库 yum install glibc.i686 glibc是GNU发布的libc库，即c运行库。glibc是linux系统中最底层的api，几乎其它任何运行库都会依赖于glibc。glibc除了封装linux操作系统所提供的系统服务外，它本身也提供了许多其它一些必要功能服务的实现。由于 glibc 囊括了几乎所有的 UNIX 通行的标准，可以想见其内容包罗万象。 发行版中的i386/i686/x86-64的区别：baii386用来du处理32位系统，i686是i386的下集；x86-64用来处理64位系统。linux发行zhi版中的i386/i686/x86-64各自含义： 1、i386通常被用来作为对daoIntel（英特尔）32位微处理器的统称； 2、i386的子集包含i686，i686适用于Pentium Pro，也适用于K7架构的Athlon； 3、x86-64，又称“AMD64”或“x64”，是一种64位元的电脑处理器架构。它是建基于现有32位元的x86架构，由AMD公司所开发。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://moersuo.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"Linux","slug":"计算机基础/Linux","permalink":"http://moersuo.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://moersuo.github.io/tags/Linux/"}]},{"title":"Leetcode题解026：删除排序数组中的重复项","slug":"Leetcode题解026：删除排序数组中的重复项","date":"2020-06-23T11:35:11.000Z","updated":"2020-06-23T11:36:01.891Z","comments":true,"path":"2020/06/23/Leetcode题解026：删除排序数组中的重复项/","link":"","permalink":"http://moersuo.github.io/2020/06/23/Leetcode%E9%A2%98%E8%A7%A3026%EF%BC%9A%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/","excerpt":"","text":"删除排序数组中的重复项题目： 给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成 示例1： 给定数组 nums = [1,1,2],&emsp;函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。&emsp;你不需要考虑数组中超出新长度后面的元素。 示例2： 给定 nums = [0,0,1,1,1,2,2,3,3,4],&emsp;函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。&emsp;你不需要考虑数组中超出新长度后面的元素。 说明：为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);&emsp;// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) {print(nums[i]);}’ 官方题解：双指针思路：数组完成排序后，我们可以放置两个指针 i和 j，其中 i 是慢指针，而 j 是快指针。只要 nums[i] = nums[j]，我们就增加 j 以跳过重复项。 当我们遇到 nums[j] ≠ nums[i] 时，跳过重复项的运行已经结束，因此我们必须把它（nums[j]）的值复制到 nums[i + 1]。然后递增 i，接着我们将再次重复相同的过程，直到 j 到达数组的末尾为止。 1234567891011public int removeDuplicates(int[] nums) &#123; if (nums.length == 0) return 0; int i = 0; for (int j = 1; j &lt; nums.length; j++) &#123; if (nums[j] != nums[i]) &#123; i++; nums[i] = nums[j]; &#125; &#125; return i + 1;&#125; 时间复杂度：O(n)，假设数组的长度是 n，那么 i 和 j分别最多遍历 n 步。空间复杂度：O(1) 优化：考虑如下数组【0,1,2,3,4,5】。此时数组中没有重复元素，按照上面的说法，每次比较时 nums[j] 都不等于 nums[i]，因此就会将 j指向的元素原地复制一遍，这个操作其实是不必要的。 因此我们可以添加一个小判断，当 j- i &gt; 1 时，才进行复制。 1234567891011121314class Solution &#123; public int removeDuplicates(int[] nums) &#123; int i = 0; for(int j = 1; j &lt;nums.length; j++)&#123; if(nums[i] != nums[j])&#123; if(j-i &gt; 1)&#123; nums[i+1] = nums[j]; &#125; i++; &#125; &#125; return i+1; &#125;&#125; 时间复杂度：O(n)空间复杂度：O(1) JS：123456789101112var removeDuplicates = function(nums) &#123; const size = nums.length; if(size==0) return 0; let slowP = 0; for (let fastP = 0; fastP &lt; size; fastP++) &#123; if (nums[fastP] !== nums[slowP]) &#123; slowP++; nums[slowP] = nums[fastP] &#125; &#125; return slowP + 1;&#125;; 变形：Leetcode027 移除元素给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 官方题解1：双指针思路：当 nums[j] 与给定的值相等时，递增 j 以跳过该元素。只要 nums[j]不等于val，我们就复制 nums[j]到 nums[i]并同时递增两个索引。重复这一过程，直到 j 到达数组的末尾，该数组的新长度为 i。 12345678910public int removeElement(int[] nums, int val) &#123; int i = 0; for (int j = 0; j &lt; nums.length; j++) &#123; if (nums[j] != val) &#123; nums[i] = nums[j]; i++; &#125; &#125; return i;&#125; 时间复杂度：O(n)，假设数组总共有 n 个元素，i 和 j 至少遍历 2n 步。空间复杂度：O(1) 官方题解2：双指针–当要删除的元素很少时思路：现在考虑数组包含很少的要删除的元素的情况。例如，num=[1，2，3，5，4]，Val=4。之前的算法会对前四个元素做不必要的复制操作。另一个例子是 num=[4，1，2，3，5]，Val=4。似乎没有必要将 [1，2，3，5]这几个元素左移一步，因为问题描述中提到元素的顺序可以更改。 当我们遇到 nums[i] = val 时，我们可以将当前元素与最后一个元素进行交换，并释放最后一个元素。这实际上使数组的大小减少了 1。 请注意，被交换的最后一个元素可能是您想要移除的值。但是不要担心，在下一次迭代中，我们仍然会检查这个元素。 1234567891011121314public int removeElement(int[] nums, int val) &#123; int i = 0; int n = nums.length; while (i &lt; n) &#123; if (nums[i] == val) &#123; nums[i] = nums[n - 1]; // reduce array size by one n--; &#125; else &#123; i++; &#125; &#125; return n;&#125; 时间复杂度：O(n)，i 和 n 最多遍历 n 步。在这个方法中，赋值操作的次数等于要删除的元素的数量。因此，如果要移除的元素很少，效率会更高。空间复杂度：O(1)。","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode题解","slug":"算法/Leetcode题解","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://moersuo.github.io/tags/Leetcode%E9%A2%98%E8%A7%A3/"}]},{"title":"Leetcode题解021：合并两个有序的链表","slug":"Leetcode题解021：合并两个有序的链表","date":"2020-06-22T14:39:16.000Z","updated":"2020-06-22T14:40:54.804Z","comments":true,"path":"2020/06/22/Leetcode题解021：合并两个有序的链表/","link":"","permalink":"http://moersuo.github.io/2020/06/22/Leetcode%E9%A2%98%E8%A7%A3021%EF%BC%9A%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/","excerpt":"","text":"合并两个有序的链表题目： 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 官方解法1：递归想法：我们可以如下递归地定义在两个链表里的 merge 操作（忽略边界情况，比如空链表等）: list1[0]+merge(list1[1:],list2) &emsp;list1[0]&lt;list2[0]list2[0]+merge(list1,list2[1:]) &emsp;otherwise 算法：如果 l1 或者 l2 一开始就是 null ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个的头元素更小，然后递归地决定下一个添加到结果里的值。如果两个链表都是空的，那么过程终止，所以递归过程最终一定会终止。终止条件：两条链表分别名为 l1 和 l2，当 l1 为空或 l2 为空时结束返回值：每一层调用都返回排序好的链表头 12345678910111213141516171819class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) &#123; return l2; &#125; else if (l2 == null) &#123; return l1; &#125; else if (l1.val &lt; l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125; &#125;&#125; 时间复杂度：O(n+m)。 因为每次调用递归都会去掉 l1 或者 l2 的头元素（直到至少有一个链表为空），函数 mergeTwoList 中只会遍历每个元素一次。所以，时间复杂度与合并后的链表长度为线性关系。 空间复杂度：O(n+m)。调用 mergeTwoLists 退出时 l1 和 l2 中每个元素都一定已经被遍历过了，所以 n + mn+m 个栈帧会消耗 O(n + m)O(n+m) 的空间 官方解法2：迭代想法：我们可以用迭代的方法来实现上述算法。我们假设 l1 元素严格比 l2元素少，我们可以将 l2 中的元素逐一插入 l1 中正确的位置。算法：首先，我们设定一个哨兵节点 “prehead” ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 prev 指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：如果 l1 当前位置的值小于等于 l2 ，我们就把 l1 的值接在 prev 节点的后面同时将 l1 指针往后移一个。否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都把 prev 向后移一个元素。 在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表。 12345678910111213141516171819202122class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode prehead = new ListNode(-1); ListNode prev = prehead; // 保持对返回节点前面的节点的引用不变。 while (l1 != null &amp;&amp; l2 != null) &#123; if (l1.val &lt;= l2.val) &#123; prev.next = l1; l1 = l1.next; &#125; else &#123; prev.next = l2; l2 = l2.next; &#125; prev = prev.next; &#125; //l1，l2此时恰有一个非空，将其合并到合并列表的末尾 prev.next = l1 == null ? l2 : l1; //l1为空则pre.next = l2，反之亦然 return prehead.next; &#125;&#125; JS：123456789101112131415const mergeTwoLists = function (l1, l2) &#123; if (l1 === null) &#123; return l2; &#125; if (l2 === null) &#123; return l1; &#125; if (l1.val &lt; l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode题解","slug":"算法/Leetcode题解","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://moersuo.github.io/tags/Leetcode%E9%A2%98%E8%A7%A3/"}]},{"title":"Leetcode题解020：有效的括号","slug":"Leetcode题解020：有效的括号","date":"2020-06-19T12:50:04.000Z","updated":"2020-06-22T14:40:23.587Z","comments":true,"path":"2020/06/19/Leetcode题解020：有效的括号/","link":"","permalink":"http://moersuo.github.io/2020/06/19/Leetcode%E9%A2%98%E8%A7%A3020%EF%BC%9A%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/","excerpt":"","text":"有效的括号题目： 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。有效字符串需满足：1.左括号必须用相同类型的右括号闭合。2.左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 示例： 输入: “()”输出: true 输入: “()[]{}”输出: true 输入: “(]”输出: false 输入: “([)]”输出: false 输入: “{[]}”输出: true Java：官方题解：1.建立哈希表。2.初始化栈 S，一次处理表达式的每个括号。3.如果遇到开括号，我们只需将其推到栈上即可。这意味着我们将稍后处理它。4.如果我们遇到一个闭括号，那么我们检查栈顶的元素。如果栈顶的元素是一个相同类型的左括号，那么我们将它从栈中弹出并继续处理。否则，这意味着表达式无效。5.如果到最后我们剩下的栈中仍然有元素，那么这意味着表达式无效。 时间复杂度： O(n)，因为我们一次只遍历给定的字符串中的一个字符并在栈上进行 O(1) 的推入和弹出操作。空间复杂度： O(n)，当我们将所有的开括号都推到栈上时以及在最糟糕的情况下，我们最终要把所有括号推到栈上。例如 ((((((((((。 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; // 负责映射的哈希表。 private HashMap&lt;Character, Character&gt; mappings; // 使用映射初始化哈希映射。这只是使代码更易于阅读。 public Solution() &#123; this.mappings = new HashMap&lt;Character, Character&gt;(); this.mappings.put(')', '('); // this区分成员变量与局部变量 this.mappings.put('&#125;', '&#123;'); this.mappings.put(']', '['); &#125; public boolean isValid(String s) &#123; // 初始化堆栈 Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); // 如果当前字符是右括号 if (this.mappings.containsKey(c)) &#123; // 获取堆栈的顶部元素。如果堆栈是空的，设置一个虚拟值’ # ’ char topElement = stack.empty() ? '#' : stack.pop(); // 如果这个括号的映射与堆栈的顶部元素不匹配，则返回 false。 if (topElement != this.mappings.get(c)) &#123; return false; &#125; &#125; else &#123; // 如果它是一个左括号，则推入堆栈。 stack.push(c); &#125; &#125; // 如果堆栈仍然包含元素，则它是无效的表达式。 return stack.isEmpty(); &#125;&#125; 法二：不使用map遍历祖符串数组中的每个字符c，将每个左括号对应的括号堆入栈中，直到为右括号时，弹出栈元素中储存的右括号元素，比较二者是否相等。 123456789101112131415161718192021class Solution &#123; public boolean isValid(String s) &#123; if(s.isEmpty()) return true; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for(char c:s.toCharArray())&#123; if(c=='(') stack.push(')'); else if(c=='&#123;') stack.push('&#125;'); else if(c=='[') stack.push(']'); else if(stack.empty()||c!=stack.pop()) /* 当不为左括号时候，说明c是右括号， stack.pop弹出栈元素中存储的右括号元素，比较这两个右括号是否相等。*/ return false; &#125; if(stack.empty()) return true; return stack.isEmpty(); &#125;&#125; JS： 12345678910111213141516171819202122232425var isValid = function(s) &#123; let valid = true; const stack = []; const mapper = &#123; '&#123;': \"&#125;\", \"[\": \"]\", \"(\": \")\" &#125; for(let i in s) &#123; const v = s[i]; if (['(', '[', '&#123;'].indexOf(v) &gt; -1) &#123; stack.push(v); &#125; else &#123; const peak = stack.pop(); if (v !== mapper[peak]) &#123; return false; &#125; &#125; &#125; if (stack.length &gt; 0) return false; return valid;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode题解","slug":"算法/Leetcode题解","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://moersuo.github.io/tags/Leetcode%E9%A2%98%E8%A7%A3/"}]},{"title":"Leetcode题解01: 两数之和","slug":"Leetcode题解01-两数之和","date":"2020-06-18T15:50:04.000Z","updated":"2020-06-19T16:41:17.940Z","comments":true,"path":"2020/06/18/Leetcode题解01-两数之和/","link":"","permalink":"http://moersuo.github.io/2020/06/18/Leetcode%E9%A2%98%E8%A7%A301-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"两数之和 题目：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例： 给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] JAVA：官方题解方法一： 暴力法遍历每个元素x，并查找是否存在一个值与 target −x 相等的目标元素。 ·时间复杂度： O(n^2)对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n) 的时间。因此时间复杂度为 O(n^2)·空间复杂度：o（1） 12345678910111213class Solution &#123; public int[] twoSum(int[] nums, int target)&#123; //返回值;方法名;参数 for(int i = 0; i&lt;nums.length; i++)&#123; for(int j = i + 1; j &lt; nums.length; j++)&#123; if(nums[j] == target - nums[i])&#123; return new int[] &#123; i,j &#125;; &#125; &#125; &#125; throw new IllegalArgumentException(\"No two sum solution\"); //不合法的参数 &#125;&#125; 官方方法二：两遍哈希表为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。 通过以空间换取速度的方式，我们可以将查找时间从 O(n)O(n) 降低到 O(1)O(1)。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)O(1)。 一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i] 本身！·时间复杂度：O(n)，我们把包含有 n 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1) ，所以时间复杂度为 O(n)。 ·空间复杂度：O(n)，所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 n 个元素。 123456789101112131415class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; map.put(nums[i], i); &#125; for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123; return new int[] &#123; i, map.get(complement) &#125;; &#125; &#125; throw new IllegalArgumentException(\"No two sum solution\"); &#125;&#125; 官方题解方法三： 一遍哈希表事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。 12345678910111213class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement)) &#123; // 用于判断Map键中是否包含某个键 return new int[] &#123; map.get(complement), i &#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException(\"No two sum solution\"); &#125;&#125; ·时间复杂度：O(n)，我们只遍历了包含有 n 个元素的列表一次。在表中进行的每次查找只花费 O(1)的时间。 ·空间复杂度：O(n)，所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n个元素。 JS：哈希表12345678910const twoSum = function (nums, target) &#123; const map = new Map(); for (let i = 0; i &lt; nums.length; i++) &#123; const diff = target - nums[i]; if (map.has(diff)) &#123; return [map.get(diff), i]; &#125; map.set(nums[i], i); &#125;&#125; 变种：假设数组为有序排列给出left，right左右两指针。初始值分为左右两端。当两者和小于目标值时，左指针向右移一位，当两者和大于目标值时，右指针向左移一位。time: o(n), spece: o(1)； 12345678910111213141516public int[] twoSum(int[] nums, int target) &#123; if (nums == null || nums.length &lt;= 1) return new int[2]; int left = 0; int right = nums.length - 1; while (left &lt; right) &#123; int sum = nums[left] + nums[right]; if (sum &lt; target) &#123; left++; &#125; else if (sum &gt; target) &#123; right--; &#125; else &#123; return new int[] &#123;left, right&#125;; &#125; &#125; return new int[2]; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode题解","slug":"算法/Leetcode题解","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://moersuo.github.io/tags/Leetcode%E9%A2%98%E8%A7%A3/"}]}],"categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"剑指offer","slug":"算法/剑指offer","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"},{"name":"后端学习","slug":"后端学习","permalink":"http://moersuo.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"},{"name":"数据库","slug":"后端学习/数据库","permalink":"http://moersuo.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"多线程","slug":"后端学习/多线程","permalink":"http://moersuo.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"Leetcode题解","slug":"算法/Leetcode题解","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://moersuo.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"Linux","slug":"计算机基础/Linux","permalink":"http://moersuo.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Linux/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://moersuo.github.io/tags/%E5%89%91%E6%8C%87offer/"},{"name":"MySQL","slug":"MySQL","permalink":"http://moersuo.github.io/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"http://moersuo.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"多线程","slug":"多线程","permalink":"http://moersuo.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://moersuo.github.io/tags/Leetcode%E9%A2%98%E8%A7%A3/"},{"name":"Linux","slug":"Linux","permalink":"http://moersuo.github.io/tags/Linux/"}]}