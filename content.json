{"meta":{"title":"Morsol","subtitle":"","description":"","author":"morsol","url":"http://moersuo.github.io","root":"/moersuo.github.io/"},"pages":[],"posts":[{"title":"Leetcode题解020：有效的括号","slug":"title","date":"2020-06-19T16:23:51.000Z","updated":"2020-06-19T16:27:24.845Z","comments":true,"path":"2020/06/20/title/","link":"","permalink":"http://moersuo.github.io/2020/06/20/title/","excerpt":"","text":"有效的括号题目： 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。有效字符串需满足：1.左括号必须用相同类型的右括号闭合。2.左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 示例： 输入: “()”输出: true 输入: “()[]{}”输出: true 输入: “(]”输出: false 输入: “([)]”输出: false 输入: “{[]}”输出: true Java：官方题解：1.建立哈希表。2.初始化栈 S，一次处理表达式的每个括号。3.如果遇到开括号，我们只需将其推到栈上即可。这意味着我们将稍后处理它。4.如果我们遇到一个闭括号，那么我们检查栈顶的元素。如果栈顶的元素是一个相同类型的左括号，那么我们将它从栈中弹出并继续处理。否则，这意味着表达式无效。5.如果到最后我们剩下的栈中仍然有元素，那么这意味着表达式无效。 时间复杂度： O(n)，因为我们一次只遍历给定的字符串中的一个字符并在栈上进行 O(1) 的推入和弹出操作。空间复杂度： O(n)，当我们将所有的开括号都推到栈上时以及在最糟糕的情况下，我们最终要把所有括号推到栈上。例如 ((((((((((。 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; // 负责映射的哈希表。 private HashMap&lt;Character, Character&gt; mappings; // 使用映射初始化哈希映射。这只是使代码更易于阅读。 public Solution() &#123; this.mappings = new HashMap&lt;Character, Character&gt;(); this.mappings.put(')', '('); // this区分成员变量与局部变量 this.mappings.put('&#125;', '&#123;'); this.mappings.put(']', '['); &#125; public boolean isValid(String s) &#123; // 初始化堆栈 Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); // 如果当前字符是右括号 if (this.mappings.containsKey(c)) &#123; // 获取堆栈的顶部元素。如果堆栈是空的，设置一个虚拟值’ # ’ char topElement = stack.empty() ? '#' : stack.pop(); // 如果这个括号的映射与堆栈的顶部元素不匹配，则返回 false。 if (topElement != this.mappings.get(c)) &#123; return false; &#125; &#125; else &#123; // 如果它是一个左括号，则推入堆栈。 stack.push(c); &#125; &#125; // 如果堆栈仍然包含元素，则它是无效的表达式。 return stack.isEmpty(); &#125;&#125; 法二：不使用map遍历祖符串数组中的每个字符c，将每个左括号对应的括号堆入栈中，直到为右括号时，弹出栈元素中储存的右括号元素，比较二者是否相等。 123456789101112131415161718192021class Solution &#123; public boolean isValid(String s) &#123; if(s.isEmpty()) return true; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for(char c:s.toCharArray())&#123; if(c=='(') stack.push(')'); else if(c=='&#123;') stack.push('&#125;'); else if(c=='[') stack.push(']'); else if(stack.empty()||c!=stack.pop()) /* 当不为左括号时候，说明c是右括号， stack.pop弹出栈元素中存储的右括号元素，比较这两个右括号是否相等。*/ return false; &#125; if(stack.empty()) return true; return stack.isEmpty(); &#125;&#125; JS： 12345678910111213141516171819202122232425var isValid = function(s) &#123; let valid = true; const stack = []; const mapper = &#123; '&#123;': \"&#125;\", \"[\": \"]\", \"(\": \")\" &#125; for(let i in s) &#123; const v = s[i]; if (['(', '[', '&#123;'].indexOf(v) &gt; -1) &#123; stack.push(v); &#125; else &#123; const peak = stack.pop(); if (v !== mapper[peak]) &#123; return false; &#125; &#125; &#125; if (stack.length &gt; 0) return false; return valid;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode题解","slug":"算法/Leetcode题解","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://moersuo.github.io/tags/Leetcode%E9%A2%98%E8%A7%A3/"}]},{"title":"Leetcode题解01: 两数之和","slug":"Leetcode题解01-两数之和","date":"2020-06-18T15:50:04.000Z","updated":"2020-06-19T13:30:18.284Z","comments":true,"path":"2020/06/18/Leetcode题解01-两数之和/","link":"","permalink":"http://moersuo.github.io/2020/06/18/Leetcode%E9%A2%98%E8%A7%A301-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"两数之和 题目：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例： 给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] JAVA：官方题解方法一： 暴力法遍历每个元素x，并查找是否存在一个值与 target −x 相等的目标元素。 ·时间复杂度： O(n^2)对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n) 的时间。因此时间复杂度为 O(n^2)·空间复杂度：o（1） 12345678910111213class Solution &#123; public int[] twoSum(int[] nums, int target)&#123; //返回值;方法名;参数 for(int i = 0; i&lt;nums.length; i++)&#123; for(int j = i + 1; j &lt; nums.length; j++)&#123; if(nums[j] == target - nums[i])&#123; return new int[] &#123; i,j &#125;; &#125; &#125; &#125; throw new IllegalArgumentException(\"No two sum solution\"); //不合法的参数 &#125;&#125; 官方方法二：两遍哈希表为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。 通过以空间换取速度的方式，我们可以将查找时间从 O(n)O(n) 降低到 O(1)O(1)。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)O(1)。 一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i] 本身！·时间复杂度：O(n)，我们把包含有 n 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1) ，所以时间复杂度为 O(n)。 ·空间复杂度：O(n)，所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 n 个元素。 123456789101112131415class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; map.put(nums[i], i); &#125; for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123; return new int[] &#123; i, map.get(complement) &#125;; &#125; &#125; throw new IllegalArgumentException(\"No two sum solution\"); &#125;&#125; 官方题解方法三： 一遍哈希表事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。 12345678910111213class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement)) &#123; // 用于判断Map键中是否包含某个键 return new int[] &#123; map.get(complement), i &#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException(\"No two sum solution\"); &#125;&#125; ·时间复杂度：O(n)，我们只遍历了包含有 n 个元素的列表一次。在表中进行的每次查找只花费 O(1)的时间。 ·空间复杂度：O(n)，所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n个元素。 JS：哈希表12345678910const twoSum = function (nums, target) &#123; const map = new Map(); for (let i = 0; i &lt; nums.length; i++) &#123; const diff = target - nums[i]; if (map.has(diff)) &#123; return [map.get(diff), i]; &#125; map.set(nums[i], i); &#125;&#125; 变种：假设数组为有序排列给出left，right左右两指针。初始值分为左右两端。当两者和小于目标值时，左指针向右移一位，当两者和大于目标值时，右指针向左移一位。time: o(n), spece: o(1)； 12345678910111213141516public int[] twoSum(int[] nums, int target) &#123; if (nums == null || nums.length &lt;= 1) return new int[2]; int left = 0; int right = nums.length - 1; while (left &lt; right) &#123; int sum = nums[left] + nums[right]; if (sum &lt; target) &#123; left++; &#125; else if (sum &gt; target) &#123; right--; &#125; else &#123; return new int[] &#123;left, right&#125;; &#125; &#125; return new int[2]; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode题解","slug":"算法/Leetcode题解","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://moersuo.github.io/tags/Leetcode%E9%A2%98%E8%A7%A3/"}]}],"categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode题解","slug":"算法/Leetcode题解","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://moersuo.github.io/tags/Leetcode%E9%A2%98%E8%A7%A3/"}]}