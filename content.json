{"meta":{"title":"Morsol","subtitle":"","description":"","author":"morsol","url":"http://moersuo.github.io","root":"/moersuo.github.io/"},"pages":[],"posts":[{"title":"Leetcode题解09 回文数","slug":"Leetcode题解09-回文数","date":"2020-10-04T03:36:19.000Z","updated":"2020-10-04T06:16:35.938Z","comments":true,"path":"2020/10/04/Leetcode题解09-回文数/","link":"","permalink":"http://moersuo.github.io/2020/10/04/Leetcode%E9%A2%98%E8%A7%A309-%E5%9B%9E%E6%96%87%E6%95%B0/","excerpt":"","text":"Leetcode题解09 ：回文数题目： 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例： 输入: 121输出: true 输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。 官方法一：反转一半数字思路： 映入脑海的第一个想法便是将整个数字反转，再与原数字比较，如果他们相同则数字为回文数，但这可能会使反转后的数字大于int.max,产生整数溢出问题。 由此我们可以考虑反转整数的一半，回文数的后半部分反转后应该与前半部分相等。 首先处理临界问题 对于数字 1221，如果执行 1221 % 10，我们将得到最后一位数字 1，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以 10 的余数，122 % 10 = 2，就可以得到倒数第二位数字。如果我们把最后一位数字乘以 10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了我们想要的反转后的数字。如果继续这个过程，我们将得到更多位数的反转数字。 判断反转数字是否达到原始数字的一半：由于整个过程我们不断将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于或等于反转后的数字时，就意味着我们已经处理了一半位数的数字了。若出现入1321这样的情况，则非回文数，不影响结果。 代码:123456789101112131415161718192021222324class Solution &#123;public: bool isPalindrome(int x) &#123; // 特殊情况： // 如上所述，当 x &lt; 0 时，x 不是回文数。 // 同样地，如果数字的最后一位是 0，为了使该数字为回文， // 则其第一位数字也应该是 0 // 只有 0 满足这一属性 if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) &#123; return false; &#125; int revertedNumber = 0; while (x &gt; revertedNumber) &#123; revertedNumber = revertedNumber * 10 + x % 10; x /= 10; &#125; // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。 // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123， // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。 return x == revertedNumber || x == revertedNumber / 10; &#125;&#125;; 复杂度分析：时间复杂度：O(log n)，对于每次迭代，我们会将输入除以 10，因此时间复杂度为O(logn)。空间复杂度：O(1)。我们只需要常数空间存放若干变量。 法二：数学解法思路：通过取整和取余操作获取整数中对应的数字进行比较。 举个例子：1221 这个数字。 通过计算 1221 / 1000， 得首位1 通过计算 1221 % 10， 可得末位 1 进行比较 再将 22 取出来继续比较 代码:1234567891011121314151617class Solution &#123; public boolean isPalindrome(int x) &#123; //边界判断 if (x &lt; 0) return false; int div = 1; // while (x / div &gt;= 10) div *= 10; while (x &gt; 0) &#123; int left = x / div; int right = x % 10; if (left != right) return false; x = (x % div) / 10; div /= 100; &#125; return true; &#125;&#125; 法三:整数转字符串(看个乐)代码:123456class Solution &#123; public boolean isPalindrome(int x) &#123; String reversedStr = (new StringBuilder(x + \"\")).reverse().toString(); return (x + \"\").equals(reversedStr); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"算法/Leetcode","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://moersuo.github.io/tags/Leetcode/"}]},{"title":"剑指offer 05替换空格","slug":"剑指offer-05替换空格","date":"2020-10-02T08:09:27.000Z","updated":"2020-10-03T11:45:10.807Z","comments":true,"path":"2020/10/02/剑指offer-05替换空格/","link":"","permalink":"http://moersuo.github.io/2020/10/02/%E5%89%91%E6%8C%87offer-05%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/","excerpt":"","text":"剑指offer 05替换空格：题目： 请实现一个函数，把字符串 s 中的每个空格替换成”%20”。 示例： 输入：s = “We are happy.”输出：”We%20are%20happy.” 限制： 0 &lt;= s 的长度 &lt;= 10000 官方法一：思路：由于每次替换从 1 个字符变成 3 个字符，使用字符数组可方便地进行替换。建立字符数组地长度为 s 的长度的 3 倍，这样可保证字符数组可以容纳所有替换后的字符。 1.创建字符数组，其长度为length * 3 2.初始化size为0，size表示替换后的字符串的长度 3.从左到右遍历字符串s 利用charAt方法获得s的当前字符c 如果c为空格，则利用size的三次自增使得array[size] = “%”,array[size+1] = “2”,array[size+2] = “0”,且size增加3 如果c不是空格，则另array[size] = c，且size加1 4.遍历结束后，size的值等于替换后字符串的长度，从array的前size个字符创建新字符串，并返回 代码：12345678910111213141516171819class Solution &#123; public String replaceSpace(String s) &#123; int length = s.length(); char[] array = new char[length * 3]; int size = 0; for (int i = 0; i &lt; length; i++) &#123; char c = s.charAt(i); if (c == ' ') &#123; array[size++] = '%'; array[size++] = '2'; array[size++] = '0'; &#125; else &#123; array[size++] = c; &#125; &#125; String newStr = new String(array, 0, size); return newStr; &#125;&#125; 复杂度分析： 时间复杂度：O(n)。遍历字符串 s 一遍。 空间复杂度：O(n)。额外创建字符数组，长度为 s 的长度的 3 倍。 法二：思路：和上面差不多，就是把字符串中的每个字符一个个添加到StringBuilder中，如果遇到空格就把他换成%20。 代码：12345678910public String replaceSpace(String s) &#123; StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; s.length(); i++) &#123; if (s.charAt(i) == ' ') stringBuilder.append(\"%20\"); else stringBuilder.append(s.charAt(i)); &#125; return stringBuilder.toString(); &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"剑指offer","slug":"算法/剑指offer","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://moersuo.github.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"线程的五大状态","slug":"线程的五大状态","date":"2020-09-29T09:26:52.000Z","updated":"2020-10-03T11:55:29.590Z","comments":true,"path":"2020/09/29/线程的五大状态/","link":"","permalink":"http://moersuo.github.io/2020/09/29/%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%94%E5%A4%A7%E7%8A%B6%E6%80%81/","excerpt":"","text":"线程的五大状态：概述：线程的五大状态为：创建状态，就绪状态，阻塞状态，运行状态，死亡状态 new: Thread t = new Thread() 线程一旦创建，就进入到了创建状态。 就绪状态： 当调用start()方法，线程立即进入就绪状态，但不意味着立即调度执行。 运行状态：进入运行状态，线程才真正执行线程体的代码块。 阻塞状态： 当调用sleep，wait或同步锁定时，线程进入阻塞状态，就是代码不往下执行，阻塞事件解除后，重新进入就绪状态，等待cpu调度执行。 dead：线程中断或结束，一旦进入死亡状态，就不能再次启动。 停止线程：1.不推荐使用JDK提供的stop(),destory()方法 2.最好让线程自己停下来 3.建议使用一个标志位进行终止变量，当flag = false 时，终止线程运行。 样例：123456789101112131415161718192021222324252627282930package multithread.state;public class TestStop implements Runnable&#123; //1.设置1个标识位 private boolean flag = true; @Override public void run()&#123; int i =0; while(flag)&#123; System.out.println(\"run...Thread\"+i++); &#125; &#125; //2.设置一个公开的方法停止线程，转换标识位 public void stop()&#123; this.flag = false; &#125; public static void main(String[] args)&#123; TestStop testStop = new TestStop(); new Thread(testStop).start(); for (int i = 0; i &lt; 1000; i++) &#123; System.out.println(\"lalala\"+i); if(i == 900)&#123; //调用stop方法切换标识为，让线程停止 testStop.stop(); System.out.println(\"线程该停止了\"); &#125; &#125; &#125;&#125; 线程休眠： sleep(时间) 指定当前线程阻塞的毫秒数； sleep存在异常interruptedException; sleep时间达到后线程进入就绪状态 sleep可以模拟网络延时，倒计时等。 每个对象都有一个锁，sleep不会释放锁。 样例1：模拟抢票1234567891011121314151617181920212223242526package multithread.state;// 模拟抢票public class TestSleep implements Runnable&#123; // 票数 private int ticketNums = 10; public void run()&#123; while(true)&#123; if(ticketNums &lt;= 0) &#123; break; &#125; System.out.println(Thread.currentThread().getName()+\"抢到了第\"+ticketNums--+\"张票\"); &#125; // 模拟延时 try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args)&#123; TestSleep ticket = new TestSleep(); new Thread(ticket,\"小明\").start(); new Thread(ticket,\"小王\").start(); new Thread(ticket,\"小张\").start(); &#125;&#125; 样例2：模拟倒计时123456789101112131415161718192021package multithread.state;//模拟倒计时public class TestSleep2 &#123; public static void turndown() throws InterruptedException &#123; int num = 10; while(true)&#123; Thread.sleep(1000); System.out.println(num--); if(num &lt; 0)&#123; break; &#125; &#125; &#125; public static void main(String[] args)&#123; try &#123; turndown(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 线程礼让： 礼让线程，让当前正在执行的线程暂停，但不阻塞。 将线程从运行状态转为就绪状态 让cpu重新调度，礼让不一定成功，看cpu心情。 样例： 1234567891011121314151617package multithread.state;public class TestYield&#123; public static void main(String[] args )&#123; MyYield testYield= new MyYield(); new Thread(testYield,\"1\").start(); new Thread(testYield,\"2\").start(); &#125;&#125;class MyYield implements Runnable&#123; @Override public void run()&#123; System.out.println(Thread.currentThread().getName()+\"开始运行\"); Thread.yield(); System.out.println(Thread.currentThread().getName()+\"停止运行\"); &#125;&#125; 线程强制执行： 某一个线程对象可以一直独占资源，其他线程阻塞，一直到该线程的程序执行结束。 可以想象成插队 123456789101112131415161718192021package multithread.state;public class TestJoin implements Runnable&#123; @Override public void run()&#123; for(int i = 0; i &lt; 1000; i++)&#123; System.out.println(\"我是\"+i); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; TestJoin testJoin = new TestJoin(); Thread thread = new Thread(testJoin); thread.start(); for(int i = 0; i &lt; 1000; i++)&#123; if(i == 200)&#123; thread.join(); &#125; System.out.println(\"你是\"+i); &#125; &#125;&#125; 观察线程状态：12345678910111213141516171819202122232425262728293031323334package multithread.state;import javax.swing.*;//观察线程状态public class TestState &#123; public static void main(String[] args) throws InterruptedException &#123; Thread thread = new Thread(()-&gt;&#123; for(int i = 0; i &lt; 5; i++)&#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(\"lalala\"); &#125;); //观察状态 Thread.State state = thread.getState(); System.out.println(state); // NEW //观察启动后 thread.start(); state = thread.getState(); System.out.println(state); //RUN while(state != Thread.State.TERMINATED)&#123;//只要线程不停止，就一直输出状态 Thread.sleep(100); state = thread.getState();//更新线程状态 System.out.println(state);//输出状态 &#125; &#125;&#125; ​","categories":[{"name":"后端学习","slug":"后端学习","permalink":"http://moersuo.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"},{"name":"多线程","slug":"后端学习/多线程","permalink":"http://moersuo.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://moersuo.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"剑指offer 04二维数组中的查找","slug":"剑指offer-04二维数组中的查找","date":"2020-09-29T08:26:50.000Z","updated":"2020-09-29T09:10:26.639Z","comments":true,"path":"2020/09/29/剑指offer-04二维数组中的查找/","link":"","permalink":"http://moersuo.github.io/2020/09/29/%E5%89%91%E6%8C%87offer-04%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/","excerpt":"","text":"剑指offer 04：二维数组中的查找题目： 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例：现有矩阵matrix如下 [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 限制： 0 &lt;= n &lt;= 1000 0 &lt;= m &lt;= 1000 官方法一：暴力思路：在不考虑二维数组已经排好序的情况下，直接遍历整个二维数组的每一个元素，判断目标值是否在二维数组中存在。 注：二维数组的行列长度可用 int rows = matrix.length, columns = matrix[0].length; 表示 代码：12345678910111213141516class Solution &#123; public boolean findNumberIn2DArray(int[][] matrix, int target) &#123; if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123; return false; &#125; int rows = matrix.length, columns = matrix[0].length; for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; columns; j++) &#123; if (matrix[i][j] == target) &#123; return true; &#125; &#125; &#125; return false; &#125;&#125; 复杂度分析： 时间复杂度：O(nm)。二维数组中的每个元素都被遍历，因此时间复杂度为二维数组的大小。 空间复杂度：O(n)。 官方法二：线性查找思路：由于给的的数组为有序的，因此每当访问到一个元素时便可排除部分元素。 从二维数组的右上角开始查找。如果当前元素等于目标值，则返回 true。如果当前元素大于目标值，则移到左边一列。如果当前元素小于目标值，则移到下边一行。 1.若数组为空，返回false 2.初始化行下标为0，列下标为二维数组的列数-1 3.重复以下步骤，直到行下标或列下标超出边界 获得当前下标位置的元素 num如果 num 和 target 相等，返回 true如果 num 大于 target，列下标减 1如果 num 小于 target，行下标加 1 4.循环执行完毕后仍未找到元素等于目标值，则说明不存在这样的元素，返回false。 1234567891011121314151617181920class Solution &#123; public boolean findNumberIn2DArray(int[][] matrix, int target) &#123; if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123; return false; &#125; int rows = matrix.length, columns = matrix[0].length; int row = 0, column = columns - 1; while (row &lt; rows &amp;&amp; column &gt;= 0) &#123; int num = matrix[row][column]; if (num == target) &#123; return true; &#125; else if (num &gt; target) &#123; column--; &#125; else &#123; row++; &#125; &#125; return false; &#125;&#125; 复杂度分析：时间复杂度：O(n+m)。访问到的下标的行最多增加 n 次，列最多减少 m 次，因此循环体最多执行 n + m 次。空间复杂度：O(1)。","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"剑指offer","slug":"算法/剑指offer","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://moersuo.github.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"剑指offer 03数组中重复的数字","slug":"剑指offer-03数组中重复的数字","date":"2020-09-28T12:06:24.000Z","updated":"2020-09-28T12:28:43.426Z","comments":true,"path":"2020/09/28/剑指offer-03数组中重复的数字/","link":"","permalink":"http://moersuo.github.io/2020/09/28/%E5%89%91%E6%8C%87offer-03%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/","excerpt":"","text":"剑指offer 03数组中重复的数字题目： 找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字 示例： 123输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 限制： 2 &lt;= n &lt;= 100000 java：法一 使用集合set思路：由于只需要找出数组中任意一个重复的数字，因此遍历数组，遇到重复的数字即返回。为了判断一个数字是否重复遇到，使用集合存储已经遇到的数字，如果遇到的一个数字已经在集合中，则当前的数字是重复数字。 1.初始化集合为空集合，重复的数字 pepeat = -1 2.遍历数组中的每个元素，尝试将每个元素添加入集合中。若添加失败，则证明该元素已在集合中，将元素的值赋给repeat，结束循环。 3.返回repeat 代码：12345678910111213class Solution &#123; public int findRepeatNumber(int[] nums) &#123; Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); int repeat = -1; for (int num : nums) &#123; if (!set.add(num)) &#123; repeat = num; break; &#125; &#125; return repeat; &#125;&#125; 复杂度分析： 时间复杂度：O(n)：遍历数组一遍。使用哈希集合（HashSet），添加元素的时间复杂度为 O(1)，故总的时间复杂度是 O(n)。 空间复杂度：O(n)。不重复的每个元素都可能存入集合，因此占用 O(n) 额外空间。 法二：使用临时数组思路：我们可以申请一个临时数组temp，因为nums元素中的每个元素的大小都在0~n-1之间，所以我们可以把nums中元素的值和临时数组temp建立映射关系，就是nums中元素的值是几，我们就把temp中对应的位置值加1，当temp某个位置的值大于1的时候，就表示出现了重复，我们直接返回即可 12345678910public int findRepeatNumber(int[] nums) &#123; int length = nums.length; int[] temp = new int[length]; for (int i = 0; i &lt; length; i++) &#123; temp[nums[i]]++; if (temp[nums[i]] &gt; 1) return nums[i]; &#125; return -1; &#125; 法三：原地置换思路：如果没有重复数字，那么正常排序后，数字i应该在下标为i的位置，所以思路是重头扫描数组，遇到下标为i的数字如果不是i的话，（假设为m),那么我们就拿与下标m的数字交换。在交换过程中，如果有重复的数字发生，那么终止返回ture 12345678910111213141516class Solution &#123; public int findRepeatNumber(int[] nums) &#123; int temp; for(int i=0;i&lt;nums.length;i++)&#123; while (nums[i]!=i)&#123; if(nums[i]==nums[nums[i]])&#123; return nums[i]; &#125; temp=nums[i]; nums[i]=nums[temp]; nums[temp]=temp; &#125; &#125; return -1; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"剑指offer","slug":"算法/剑指offer","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://moersuo.github.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"剑指offer 22链表中倒数第k个节点","slug":"剑指offer-22链表中倒数第k个节点","date":"2020-09-27T13:58:22.000Z","updated":"2020-09-28T08:03:12.892Z","comments":true,"path":"2020/09/27/剑指offer-22链表中倒数第k个节点/","link":"","permalink":"http://moersuo.github.io/2020/09/27/%E5%89%91%E6%8C%87offer-22%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/","excerpt":"","text":"链表中倒数第k个节点题目： 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。 实例： 123给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.返回链表 4-&gt;5. java：双指针解题思路： 利用双指针我们可以不考虑链表总长度，快指针先走k步，再让双指针同时前进，当快指针指向null时，慢指针剩下的部分即为所求值 1.初始化：建立快慢指针，均指向头结点 2.快指针向前走k步，慢指针不动 3.构建循环，双指针同时向前移动，当快指针为null跳出时，慢指针与尾结点距离为k-1，是倒数第k个节点。 4.返回慢指针 注意考虑边界问题 1）head为空指针 2）输入参数k为0 3）k大于链表长度 12345678910111213141516171819class Sloution&#123; public ListNode getKthFromEnd(ListNode head, int k) &#123; //边界问题：head为空指针，输入的参数k为0 if(head == null || k == 0) return null; ListNode fast = head,slow = head; for(int i = 0; i&lt; k ; i++)&#123; if(fast == null &amp;&amp; i &lt; k)&#123; // 边界问题：k大于链表长度 return null; &#125; fast = fast.next; &#125; while(fast!=null)&#123; fast = fast.next; slow = slow.next; &#125; return slow; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"剑指offer","slug":"算法/剑指offer","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://moersuo.github.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"三种方式实现多线程","slug":"三种方式实现多线程","date":"2020-09-27T06:19:28.000Z","updated":"2020-09-27T06:20:11.109Z","comments":true,"path":"2020/09/27/三种方式实现多线程/","link":"","permalink":"http://moersuo.github.io/2020/09/27/%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"java实现多线程的三种方式继承Thread类，实现Runnable接口，实现callable接口 *继承Thread类子类继承Thead类具备多线程能力 启动线程：子类对象.start() 不建议使用：避免OOP单继承局限性 12345678910111213141516public class Thread1 extends Thread&#123; @Override // 使用继承thread方法创建多线程 public void run()&#123; for(int i = 0; i &lt; 20; i++)&#123; System.out.println(\"我在执行分支任务\"+i); &#125; &#125; public static void main(String[] args)&#123; Thread1 thread1 = new Thread1(); thread1.start(); for(int i = 0; i &lt; 20; i++)&#123; System.out.println(\"我在执行主线任务\"+i); &#125; &#125;&#125; *实现Runnable接口实现接口Runnable具有多线程能力 启动线程：传入目标对象+Thread对象.start() 推荐使用，避免单继承局限性，灵活方便，方便同一个对象被多个线程使用 123456789101112131415161718public class Runnable1 implements Runnable&#123; @Override // 使用实现Runnable方法创建多线程 public void run()&#123; for(int i = 0; i &lt; 20; i++)&#123; System.out.println(\"我在执行分支任务\"+i); &#125; &#125; public static void main(String[] args)&#123; Runnable1 Runnable1 = new Runnable1(); //Thread thread = new Thread(Runnable1); //thread.start(); new Thread(Runnable1).start(); for(int i = 0; i &lt; 20; i++)&#123; System.out.println(\"我在执行主线任务\"+i); &#125; &#125;&#125; *实现Callable接口1.实现callable接口需要返回值类型 2.重写call方法，需要抛出异常 3.创建目标对象 4.创建执行服务：ExecutorService ser =Executors.newFixedThreadPool(1); 5.提交执行：Futureresult1=ser.submit(t1); 6.获取结果：bollean r1 = result1.get() 7.关闭服务：ser.shutdownNow(); 1234567891011121314151617181920212223242526272829package course.multithread.callable;import java.util.concurrent.*;public class CallableTest implements Callable&lt;Boolean&gt; &#123; @Override // 使用实现callable方法创建多线程 public Boolean call()&#123; for(int i = 0; i &lt; 20; i++)&#123; System.out.println(\"我在执行分支任务\"+i); &#125; return true; &#125; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; CallableTest t1= new CallableTest(); //创建执行服务： ExecutorService ser = Executors.newFixedThreadPool(1); //提交执行： Future&lt;Boolean&gt; r1 = ser.submit(t1); //获取结果： boolean rs1 = r1.get(); System.out.println(rs1); //关闭服务： ser.shutdownNow(); for(int i = 0; i &lt; 20; i++)&#123; System.out.println(\"我在执行主线任务\"+i); &#125; &#125;&#125;","categories":[{"name":"后端学习","slug":"后端学习","permalink":"http://moersuo.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"},{"name":"多线程","slug":"后端学习/多线程","permalink":"http://moersuo.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://moersuo.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Linux下JDK安装问题","slug":"Linux下JDK安装问题","date":"2020-08-17T01:25:27.000Z","updated":"2020-08-17T01:26:35.235Z","comments":true,"path":"2020/08/17/Linux下JDK安装问题/","link":"","permalink":"http://moersuo.github.io/2020/08/17/Linux%E4%B8%8BJDK%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/","excerpt":"","text":"新的linux环境下配置JDK环境出现-bash: /usr/local/jdk1.8/jdk1.8.0_181/bin/java: /lib/ld-linux.so.2: bad ELF interpreter: No such file or directory解决方法： 安装glibc.i686库 yum install glibc.i686 glibc是GNU发布的libc库，即c运行库。glibc是linux系统中最底层的api，几乎其它任何运行库都会依赖于glibc。glibc除了封装linux操作系统所提供的系统服务外，它本身也提供了许多其它一些必要功能服务的实现。由于 glibc 囊括了几乎所有的 UNIX 通行的标准，可以想见其内容包罗万象。 发行版中的i386/i686/x86-64的区别：baii386用来du处理32位系统，i686是i386的下集；x86-64用来处理64位系统。linux发行zhi版中的i386/i686/x86-64各自含义： 1、i386通常被用来作为对daoIntel（英特尔）32位微处理器的统称； 2、i386的子集包含i686，i686适用于Pentium Pro，也适用于K7架构的Athlon； 3、x86-64，又称“AMD64”或“x64”，是一种64位元的电脑处理器架构。它是建基于现有32位元的x86架构，由AMD公司所开发。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://moersuo.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"Linux","slug":"计算机基础/Linux","permalink":"http://moersuo.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://moersuo.github.io/tags/Linux/"}]},{"title":"Leetcode题解026：删除排序数组中的重复项","slug":"Leetcode题解026：删除排序数组中的重复项","date":"2020-06-23T11:35:11.000Z","updated":"2020-06-23T11:36:01.891Z","comments":true,"path":"2020/06/23/Leetcode题解026：删除排序数组中的重复项/","link":"","permalink":"http://moersuo.github.io/2020/06/23/Leetcode%E9%A2%98%E8%A7%A3026%EF%BC%9A%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/","excerpt":"","text":"删除排序数组中的重复项题目： 给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成 示例1： 给定数组 nums = [1,1,2],&emsp;函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。&emsp;你不需要考虑数组中超出新长度后面的元素。 示例2： 给定 nums = [0,0,1,1,1,2,2,3,3,4],&emsp;函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。&emsp;你不需要考虑数组中超出新长度后面的元素。 说明：为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);&emsp;// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) {print(nums[i]);}’ 官方题解：双指针思路：数组完成排序后，我们可以放置两个指针 i和 j，其中 i 是慢指针，而 j 是快指针。只要 nums[i] = nums[j]，我们就增加 j 以跳过重复项。 当我们遇到 nums[j] ≠ nums[i] 时，跳过重复项的运行已经结束，因此我们必须把它（nums[j]）的值复制到 nums[i + 1]。然后递增 i，接着我们将再次重复相同的过程，直到 j 到达数组的末尾为止。 1234567891011public int removeDuplicates(int[] nums) &#123; if (nums.length == 0) return 0; int i = 0; for (int j = 1; j &lt; nums.length; j++) &#123; if (nums[j] != nums[i]) &#123; i++; nums[i] = nums[j]; &#125; &#125; return i + 1;&#125; 时间复杂度：O(n)，假设数组的长度是 n，那么 i 和 j分别最多遍历 n 步。空间复杂度：O(1) 优化：考虑如下数组【0,1,2,3,4,5】。此时数组中没有重复元素，按照上面的说法，每次比较时 nums[j] 都不等于 nums[i]，因此就会将 j指向的元素原地复制一遍，这个操作其实是不必要的。 因此我们可以添加一个小判断，当 j- i &gt; 1 时，才进行复制。 1234567891011121314class Solution &#123; public int removeDuplicates(int[] nums) &#123; int i = 0; for(int j = 1; j &lt;nums.length; j++)&#123; if(nums[i] != nums[j])&#123; if(j-i &gt; 1)&#123; nums[i+1] = nums[j]; &#125; i++; &#125; &#125; return i+1; &#125;&#125; 时间复杂度：O(n)空间复杂度：O(1) JS：123456789101112var removeDuplicates = function(nums) &#123; const size = nums.length; if(size==0) return 0; let slowP = 0; for (let fastP = 0; fastP &lt; size; fastP++) &#123; if (nums[fastP] !== nums[slowP]) &#123; slowP++; nums[slowP] = nums[fastP] &#125; &#125; return slowP + 1;&#125;; 变形：Leetcode027 移除元素给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 官方题解1：双指针思路：当 nums[j] 与给定的值相等时，递增 j 以跳过该元素。只要 nums[j]不等于val，我们就复制 nums[j]到 nums[i]并同时递增两个索引。重复这一过程，直到 j 到达数组的末尾，该数组的新长度为 i。 12345678910public int removeElement(int[] nums, int val) &#123; int i = 0; for (int j = 0; j &lt; nums.length; j++) &#123; if (nums[j] != val) &#123; nums[i] = nums[j]; i++; &#125; &#125; return i;&#125; 时间复杂度：O(n)，假设数组总共有 n 个元素，i 和 j 至少遍历 2n 步。空间复杂度：O(1) 官方题解2：双指针–当要删除的元素很少时思路：现在考虑数组包含很少的要删除的元素的情况。例如，num=[1，2，3，5，4]，Val=4。之前的算法会对前四个元素做不必要的复制操作。另一个例子是 num=[4，1，2，3，5]，Val=4。似乎没有必要将 [1，2，3，5]这几个元素左移一步，因为问题描述中提到元素的顺序可以更改。 当我们遇到 nums[i] = val 时，我们可以将当前元素与最后一个元素进行交换，并释放最后一个元素。这实际上使数组的大小减少了 1。 请注意，被交换的最后一个元素可能是您想要移除的值。但是不要担心，在下一次迭代中，我们仍然会检查这个元素。 1234567891011121314public int removeElement(int[] nums, int val) &#123; int i = 0; int n = nums.length; while (i &lt; n) &#123; if (nums[i] == val) &#123; nums[i] = nums[n - 1]; // reduce array size by one n--; &#125; else &#123; i++; &#125; &#125; return n;&#125; 时间复杂度：O(n)，i 和 n 最多遍历 n 步。在这个方法中，赋值操作的次数等于要删除的元素的数量。因此，如果要移除的元素很少，效率会更高。空间复杂度：O(1)。","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode题解","slug":"算法/Leetcode题解","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://moersuo.github.io/tags/Leetcode%E9%A2%98%E8%A7%A3/"}]},{"title":"Leetcode题解021：合并两个有序的链表","slug":"Leetcode题解021：合并两个有序的链表","date":"2020-06-22T14:39:16.000Z","updated":"2020-06-22T14:40:54.804Z","comments":true,"path":"2020/06/22/Leetcode题解021：合并两个有序的链表/","link":"","permalink":"http://moersuo.github.io/2020/06/22/Leetcode%E9%A2%98%E8%A7%A3021%EF%BC%9A%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/","excerpt":"","text":"合并两个有序的链表题目： 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 官方解法1：递归想法：我们可以如下递归地定义在两个链表里的 merge 操作（忽略边界情况，比如空链表等）: list1[0]+merge(list1[1:],list2) &emsp;list1[0]&lt;list2[0]list2[0]+merge(list1,list2[1:]) &emsp;otherwise 算法：如果 l1 或者 l2 一开始就是 null ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个的头元素更小，然后递归地决定下一个添加到结果里的值。如果两个链表都是空的，那么过程终止，所以递归过程最终一定会终止。终止条件：两条链表分别名为 l1 和 l2，当 l1 为空或 l2 为空时结束返回值：每一层调用都返回排序好的链表头 12345678910111213141516171819class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) &#123; return l2; &#125; else if (l2 == null) &#123; return l1; &#125; else if (l1.val &lt; l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125; &#125;&#125; 时间复杂度：O(n+m)。 因为每次调用递归都会去掉 l1 或者 l2 的头元素（直到至少有一个链表为空），函数 mergeTwoList 中只会遍历每个元素一次。所以，时间复杂度与合并后的链表长度为线性关系。 空间复杂度：O(n+m)。调用 mergeTwoLists 退出时 l1 和 l2 中每个元素都一定已经被遍历过了，所以 n + mn+m 个栈帧会消耗 O(n + m)O(n+m) 的空间 官方解法2：迭代想法：我们可以用迭代的方法来实现上述算法。我们假设 l1 元素严格比 l2元素少，我们可以将 l2 中的元素逐一插入 l1 中正确的位置。算法：首先，我们设定一个哨兵节点 “prehead” ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 prev 指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：如果 l1 当前位置的值小于等于 l2 ，我们就把 l1 的值接在 prev 节点的后面同时将 l1 指针往后移一个。否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都把 prev 向后移一个元素。 在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表。 12345678910111213141516171819202122class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode prehead = new ListNode(-1); ListNode prev = prehead; // 保持对返回节点前面的节点的引用不变。 while (l1 != null &amp;&amp; l2 != null) &#123; if (l1.val &lt;= l2.val) &#123; prev.next = l1; l1 = l1.next; &#125; else &#123; prev.next = l2; l2 = l2.next; &#125; prev = prev.next; &#125; //l1，l2此时恰有一个非空，将其合并到合并列表的末尾 prev.next = l1 == null ? l2 : l1; //l1为空则pre.next = l2，反之亦然 return prehead.next; &#125;&#125; JS：123456789101112131415const mergeTwoLists = function (l1, l2) &#123; if (l1 === null) &#123; return l2; &#125; if (l2 === null) &#123; return l1; &#125; if (l1.val &lt; l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode题解","slug":"算法/Leetcode题解","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://moersuo.github.io/tags/Leetcode%E9%A2%98%E8%A7%A3/"}]},{"title":"Leetcode题解020：有效的括号","slug":"Leetcode题解020：有效的括号","date":"2020-06-19T12:50:04.000Z","updated":"2020-06-22T14:40:23.587Z","comments":true,"path":"2020/06/19/Leetcode题解020：有效的括号/","link":"","permalink":"http://moersuo.github.io/2020/06/19/Leetcode%E9%A2%98%E8%A7%A3020%EF%BC%9A%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/","excerpt":"","text":"有效的括号题目： 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。有效字符串需满足：1.左括号必须用相同类型的右括号闭合。2.左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 示例： 输入: “()”输出: true 输入: “()[]{}”输出: true 输入: “(]”输出: false 输入: “([)]”输出: false 输入: “{[]}”输出: true Java：官方题解：1.建立哈希表。2.初始化栈 S，一次处理表达式的每个括号。3.如果遇到开括号，我们只需将其推到栈上即可。这意味着我们将稍后处理它。4.如果我们遇到一个闭括号，那么我们检查栈顶的元素。如果栈顶的元素是一个相同类型的左括号，那么我们将它从栈中弹出并继续处理。否则，这意味着表达式无效。5.如果到最后我们剩下的栈中仍然有元素，那么这意味着表达式无效。 时间复杂度： O(n)，因为我们一次只遍历给定的字符串中的一个字符并在栈上进行 O(1) 的推入和弹出操作。空间复杂度： O(n)，当我们将所有的开括号都推到栈上时以及在最糟糕的情况下，我们最终要把所有括号推到栈上。例如 ((((((((((。 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; // 负责映射的哈希表。 private HashMap&lt;Character, Character&gt; mappings; // 使用映射初始化哈希映射。这只是使代码更易于阅读。 public Solution() &#123; this.mappings = new HashMap&lt;Character, Character&gt;(); this.mappings.put(')', '('); // this区分成员变量与局部变量 this.mappings.put('&#125;', '&#123;'); this.mappings.put(']', '['); &#125; public boolean isValid(String s) &#123; // 初始化堆栈 Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); // 如果当前字符是右括号 if (this.mappings.containsKey(c)) &#123; // 获取堆栈的顶部元素。如果堆栈是空的，设置一个虚拟值’ # ’ char topElement = stack.empty() ? '#' : stack.pop(); // 如果这个括号的映射与堆栈的顶部元素不匹配，则返回 false。 if (topElement != this.mappings.get(c)) &#123; return false; &#125; &#125; else &#123; // 如果它是一个左括号，则推入堆栈。 stack.push(c); &#125; &#125; // 如果堆栈仍然包含元素，则它是无效的表达式。 return stack.isEmpty(); &#125;&#125; 法二：不使用map遍历祖符串数组中的每个字符c，将每个左括号对应的括号堆入栈中，直到为右括号时，弹出栈元素中储存的右括号元素，比较二者是否相等。 123456789101112131415161718192021class Solution &#123; public boolean isValid(String s) &#123; if(s.isEmpty()) return true; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for(char c:s.toCharArray())&#123; if(c=='(') stack.push(')'); else if(c=='&#123;') stack.push('&#125;'); else if(c=='[') stack.push(']'); else if(stack.empty()||c!=stack.pop()) /* 当不为左括号时候，说明c是右括号， stack.pop弹出栈元素中存储的右括号元素，比较这两个右括号是否相等。*/ return false; &#125; if(stack.empty()) return true; return stack.isEmpty(); &#125;&#125; JS： 12345678910111213141516171819202122232425var isValid = function(s) &#123; let valid = true; const stack = []; const mapper = &#123; '&#123;': \"&#125;\", \"[\": \"]\", \"(\": \")\" &#125; for(let i in s) &#123; const v = s[i]; if (['(', '[', '&#123;'].indexOf(v) &gt; -1) &#123; stack.push(v); &#125; else &#123; const peak = stack.pop(); if (v !== mapper[peak]) &#123; return false; &#125; &#125; &#125; if (stack.length &gt; 0) return false; return valid;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode题解","slug":"算法/Leetcode题解","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://moersuo.github.io/tags/Leetcode%E9%A2%98%E8%A7%A3/"}]},{"title":"Leetcode题解01: 两数之和","slug":"Leetcode题解01-两数之和","date":"2020-06-18T15:50:04.000Z","updated":"2020-06-19T16:41:17.940Z","comments":true,"path":"2020/06/18/Leetcode题解01-两数之和/","link":"","permalink":"http://moersuo.github.io/2020/06/18/Leetcode%E9%A2%98%E8%A7%A301-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"两数之和 题目：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例： 给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] JAVA：官方题解方法一： 暴力法遍历每个元素x，并查找是否存在一个值与 target −x 相等的目标元素。 ·时间复杂度： O(n^2)对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n) 的时间。因此时间复杂度为 O(n^2)·空间复杂度：o（1） 12345678910111213class Solution &#123; public int[] twoSum(int[] nums, int target)&#123; //返回值;方法名;参数 for(int i = 0; i&lt;nums.length; i++)&#123; for(int j = i + 1; j &lt; nums.length; j++)&#123; if(nums[j] == target - nums[i])&#123; return new int[] &#123; i,j &#125;; &#125; &#125; &#125; throw new IllegalArgumentException(\"No two sum solution\"); //不合法的参数 &#125;&#125; 官方方法二：两遍哈希表为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。 通过以空间换取速度的方式，我们可以将查找时间从 O(n)O(n) 降低到 O(1)O(1)。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)O(1)。 一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i] 本身！·时间复杂度：O(n)，我们把包含有 n 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1) ，所以时间复杂度为 O(n)。 ·空间复杂度：O(n)，所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 n 个元素。 123456789101112131415class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; map.put(nums[i], i); &#125; for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123; return new int[] &#123; i, map.get(complement) &#125;; &#125; &#125; throw new IllegalArgumentException(\"No two sum solution\"); &#125;&#125; 官方题解方法三： 一遍哈希表事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。 12345678910111213class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement)) &#123; // 用于判断Map键中是否包含某个键 return new int[] &#123; map.get(complement), i &#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException(\"No two sum solution\"); &#125;&#125; ·时间复杂度：O(n)，我们只遍历了包含有 n 个元素的列表一次。在表中进行的每次查找只花费 O(1)的时间。 ·空间复杂度：O(n)，所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n个元素。 JS：哈希表12345678910const twoSum = function (nums, target) &#123; const map = new Map(); for (let i = 0; i &lt; nums.length; i++) &#123; const diff = target - nums[i]; if (map.has(diff)) &#123; return [map.get(diff), i]; &#125; map.set(nums[i], i); &#125;&#125; 变种：假设数组为有序排列给出left，right左右两指针。初始值分为左右两端。当两者和小于目标值时，左指针向右移一位，当两者和大于目标值时，右指针向左移一位。time: o(n), spece: o(1)； 12345678910111213141516public int[] twoSum(int[] nums, int target) &#123; if (nums == null || nums.length &lt;= 1) return new int[2]; int left = 0; int right = nums.length - 1; while (left &lt; right) &#123; int sum = nums[left] + nums[right]; if (sum &lt; target) &#123; left++; &#125; else if (sum &gt; target) &#123; right--; &#125; else &#123; return new int[] &#123;left, right&#125;; &#125; &#125; return new int[2]; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode题解","slug":"算法/Leetcode题解","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://moersuo.github.io/tags/Leetcode%E9%A2%98%E8%A7%A3/"}]}],"categories":[{"name":"算法","slug":"算法","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"算法/Leetcode","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"},{"name":"剑指offer","slug":"算法/剑指offer","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"},{"name":"后端学习","slug":"后端学习","permalink":"http://moersuo.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"},{"name":"多线程","slug":"后端学习/多线程","permalink":"http://moersuo.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://moersuo.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"Linux","slug":"计算机基础/Linux","permalink":"http://moersuo.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Linux/"},{"name":"Leetcode题解","slug":"算法/Leetcode题解","permalink":"http://moersuo.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://moersuo.github.io/tags/Leetcode/"},{"name":"剑指offer","slug":"剑指offer","permalink":"http://moersuo.github.io/tags/%E5%89%91%E6%8C%87offer/"},{"name":"多线程","slug":"多线程","permalink":"http://moersuo.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"Linux","slug":"Linux","permalink":"http://moersuo.github.io/tags/Linux/"},{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://moersuo.github.io/tags/Leetcode%E9%A2%98%E8%A7%A3/"}]}